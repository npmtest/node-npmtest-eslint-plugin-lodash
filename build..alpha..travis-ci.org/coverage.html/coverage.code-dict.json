{"/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/test.js":"/* istanbul instrument in package npmtest_eslint_plugin_lodash */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/lib.npmtest_eslint_plugin_lodash.js":"/* istanbul instrument in package npmtest_eslint_plugin_lodash */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_eslint_plugin_lodash = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_eslint_plugin_lodash = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-eslint-plugin-lodash && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_eslint_plugin_lodash */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_eslint_plugin_lodash\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_eslint_plugin_lodash.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_eslint_plugin_lodash.rollup.js'] =\n            local.assetsDict['/assets.npmtest_eslint_plugin_lodash.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_eslint_plugin_lodash.__dirname + '/lib.npmtest_eslint_plugin_lodash.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/index.js":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar _ = require('lodash');\nvar rules = fs.readdirSync(path.resolve(__dirname, 'rules')).map(function (f) {\n    return f.replace(/\\.js$/, '');\n});\nvar recommended = {\n    rules: {\n        'lodash/callback-binding': 2,\n        'lodash/chain-style': [2, 'as-needed'],\n        'lodash/chaining': 2,\n        'lodash/collection-method-value': 2,\n        'lodash/collection-return': 2,\n        'lodash/consistent-compose': [2, \"flow\"],\n        'lodash/identity-shorthand': [2, 'always'],\n        'lodash/import-scope': [2],\n        'lodash/matches-prop-shorthand': [2, 'always'],\n        'lodash/matches-shorthand': [2, 'always', 3],\n        'lodash/no-commit': 2,\n        'lodash/no-double-unwrap': 2,\n        'lodash/no-extra-args': 2,\n        'lodash/no-unbound-this': 2,\n        'lodash/path-style': [2, 'string'],\n        'lodash/prefer-compact': 2,\n        'lodash/prefer-constant': 2,\n        'lodash/prefer-filter': [2, 3],\n        'lodash/prefer-flat-map': 2,\n        'lodash/prefer-get': [2, 3],\n        'lodash/prefer-includes': [2, { includeNative: true }],\n        'lodash/prefer-invoke-map': 2,\n        'lodash/prefer-is-nil': 2,\n        'lodash/prefer-lodash-chain': 2,\n        'lodash/prefer-lodash-method': 2,\n        'lodash/prefer-lodash-typecheck': 2,\n        'lodash/prefer-map': 2,\n        'lodash/prefer-matches': [2, 3],\n        'lodash/prefer-noop': 2,\n        'lodash/prefer-over-quantifier': 2,\n        'lodash/prefer-reject': [2, 3],\n        'lodash/prefer-some': [2, { includeNative: true }],\n        'lodash/prefer-startswith': 2,\n        'lodash/prefer-thru': 2,\n        'lodash/prefer-times': 2,\n        'lodash/prefer-wrapper-method': 2,\n        'lodash/preferred-alias': 2,\n        'lodash/prop-shorthand': [2, 'always'],\n        'lodash/unwrap': 2\n    }\n};\nmodule.exports = {\n    rules: _.zipObject(rules, rules.map(function (rule) {\n        return require('./rules/' + rule);\n    })),\n    configs: {\n        recommended: recommended,\n        canonical: _.defaultsDeep({\n            settings: { lodash: { pragma: '_' } },\n            rules: {\n                'lodash/import-scope': [2, 'full']\n            }\n        }, recommended),\n        v3: {\n            settings: {\n                lodash: {\n                    version: 3,\n                    pragma: '_'\n                }\n            },\n            rules: {\n                'lodash/callback-binding': 2,\n                'lodash/chain-style': [2, 'as-needed'],\n                'lodash/chaining': [2, 'always'],\n                'lodash/collection-method-value': 2,\n                'lodash/collection-return': 2,\n                'lodash/consistent-compose': [2, \"flow\"],\n                'lodash/import-scope': [2, 'full'],\n                'lodash/identity-shorthand': [2, 'always'],\n                'lodash/matches-prop-shorthand': [2, 'always'],\n                'lodash/matches-shorthand': [2, 'always', 3],\n                'lodash/no-commit': 2,\n                'lodash/no-double-unwrap': 2,\n                'lodash/no-extra-args': 2,\n                'lodash/path-style': [2, 'string'],\n\n                'lodash/prefer-compact': 2,\n                'lodash/prefer-constant': 2,\n                'lodash/prefer-filter': [2, 3],\n                'lodash/prefer-get': [2, 3],\n                'lodash/prefer-includes': [2, { includeNative: true }],\n                'lodash/prefer-lodash-chain': 2,\n                'lodash/prefer-lodash-method': 2,\n                'lodash/prefer-lodash-typecheck': 2,\n                'lodash/prefer-map': 2,\n                'lodash/prefer-matches': [2, 3],\n                'lodash/prefer-noop': 2,\n                'lodash/prefer-reject': [2, 3],\n                'lodash/prefer-some': [2, { includeNative: true }],\n                'lodash/prefer-startswith': 2,\n                'lodash/prefer-thru': 2,\n                'lodash/prefer-times': 2,\n                'lodash/prefer-wrapper-method': 2,\n                'lodash/preferred-alias': 2,\n                'lodash/prop-shorthand': [2, 'always'],\n                'lodash/unwrap': 2\n            }\n        }\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/callback-binding.js":"/**\n * @fileoverview Rule to disallow the use of a chain for a single method\n */\n'use strict';\n\n/**\n * @fileoverview Rule to disallow the use of a chain for a single method\n */\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashMethodVisitors = _require.getLodashMethodVisitors;\n\n        var _require2 = require('../util/astUtil'),\n            getMethodName = _require2.getMethodName;\n\n        var _require$getSettings = require('../util/settingsUtil').getSettings(context),\n            version = _require$getSettings.version;\n\n        var methodsWithExtraArg = ['reduce', 'reduceRight', 'transform', 'find', 'findLast', 'findIndex', 'findLastIndex'];\n        var includes = require('lodash/includes');\n\n        function isBound(node) {\n            return node && node.type === 'CallExpression' && getMethodName(node) === 'bind' && node.arguments.length === 1;\n        }\n\n        var callExpressionReporters = {\n            3: function _(node, iteratee) {\n                if (isBound(iteratee)) {\n                    context.report(iteratee.callee.property, 'Unnecessary bind, pass `thisArg` to lodash method instead');\n                }\n            },\n            4: function _(node, iteratee, _ref) {\n                var method = _ref.method;\n\n                var hasExtraArg = includes(methodsWithExtraArg, method);\n                var iterateeIndex = node.arguments.indexOf(iteratee);\n                if (iterateeIndex !== -1 && (hasExtraArg && node.arguments[iterateeIndex + 2] || !hasExtraArg && node.arguments[iterateeIndex + 1])) {\n                    context.report(iteratee, 'Do not use Lodash 3 thisArg, use binding instead');\n                }\n            }\n        };\n\n        return getLodashMethodVisitors(context, callExpressionReporters[version]);\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/chain-style.js":"/**\n * @fileoverview Rule to enforce a specific chain style\n */\n'use strict';\n\n/**\n * @fileoverview Rule to enforce a specific chain style\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            enum: ['as-needed', 'implicit', 'explicit']\n        }]\n    },\n\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashContext = _require.getLodashContext,\n            isChainable = _require.isChainable,\n            isChainBreaker = _require.isChainBreaker;\n\n        var _require2 = require('../util/astUtil'),\n            isMethodCall = _require2.isMethodCall;\n\n        var lodashContext = getLodashContext(context);\n        var version = lodashContext.version;\n        var callExpressionVisitors = {\n            'as-needed': function asNeeded(node) {\n                if (lodashContext.isExplicitChainStart(node)) {\n                    var curr = node.parent.parent;\n                    var needed = false;\n                    while (isMethodCall(curr) && !isChainBreaker(curr, version)) {\n                        if (!isChainable(curr, version) && !isChainBreaker(curr.parent.parent, version)) {\n                            needed = true;\n                        }\n                        curr = curr.parent.parent;\n                    }\n                    if (isMethodCall(curr) && !needed) {\n                        context.report(node, 'Unnecessary explicit chaining');\n                    }\n                }\n            },\n            implicit: function implicit(node) {\n                if (lodashContext.isExplicitChainStart(node)) {\n                    context.report(node, 'Do not use explicit chaining');\n                }\n            },\n            explicit: function explicit(node) {\n                if (lodashContext.isImplicitChainStart(node)) {\n                    context.report(node, 'Do not use implicit chaining');\n                }\n            }\n        };\n\n        var visitors = lodashContext.getImportVisitors();\n        visitors.CallExpression = callExpressionVisitors[context.options[0] || 'as-needed'];\n        return visitors;\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/chaining.js":"/**\n * @fileoverview Rule to check if the expression could be better expressed as a chain\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if the expression could be better expressed as a chain\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            enum: ['always', 'never']\n        }, {\n            type: 'integer',\n            minimum: 2\n        }]\n    },\n\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashContext = _require.getLodashContext,\n            isChainBreaker = _require.isChainBreaker;\n\n        var _require2 = require('../util/astUtil'),\n            getCaller = _require2.getCaller,\n            isMethodCall = _require2.isMethodCall,\n            isObjectOfMethodCall = _require2.isObjectOfMethodCall;\n\n        var DEFAULT_LENGTH = 3;\n        var lodashContext = getLodashContext(context);\n        var version = lodashContext.version;\n        var negate = require('lodash/negate');\n\n        var mode = context.options[0] || 'never';\n        var ruleDepth = parseInt(context.options[1], 10) || DEFAULT_LENGTH;\n\n        var isEndOfChain = negate(isObjectOfMethodCall);\n\n        function isBeforeChainBreaker(node) {\n            return isChainBreaker(node.parent.parent, version);\n        }\n\n        function isNestedNLevels(node, n) {\n            if (n === 0) {\n                return true;\n            } else if (lodashContext.isLodashCall(node) || lodashContext.getImportedLodashMethod(node)) {\n                return isNestedNLevels(node.arguments[0], n - 1);\n            }\n        }\n\n        var callExpressionVisitors = {\n            always: function always(node) {\n                if (isNestedNLevels(node, ruleDepth)) {\n                    context.report(node, 'Prefer chaining to composition');\n                } else if (lodashContext.isLodashChainStart(node)) {\n                    var firstCall = node.parent.parent;\n                    if (isMethodCall(firstCall) && (isEndOfChain(firstCall) || isBeforeChainBreaker(firstCall))) {\n                        context.report(firstCall, 'Do not use chain syntax for single method');\n                    }\n                }\n            },\n            never: function never(node) {\n                if (lodashContext.isLodashChainStart(node)) {\n                    context.report(node, 'Prefer composition to Lodash chaining');\n                }\n            }\n        };\n\n        var visitors = lodashContext.getImportVisitors();\n        visitors.CallExpression = callExpressionVisitors[mode];\n        return visitors;\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/collection-method-value.js":"/**\n * @fileoverview Rule to enforce usage of collection method values\n */\n'use strict';\n\n/**\n * @fileoverview Rule to enforce usage of collection method values\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            isChainBreaker = _require.isChainBreaker,\n            getLodashMethodVisitors = _require.getLodashMethodVisitors,\n            isCallToMethod = _require.isCallToMethod;\n\n        var _require2 = require('../util/astUtil'),\n            getMethodName = _require2.getMethodName;\n\n        var _require3 = require('../util/methodDataUtil'),\n            isCollectionMethod = _require3.isCollectionMethod,\n            isAliasOfMethod = _require3.isAliasOfMethod,\n            getSideEffectIterationMethods = _require3.getSideEffectIterationMethods;\n\n        var includes = require('lodash/includes');\n\n        function parentUsesValue(node, callType, version) {\n            var isBeforeChainBreaker = callType === 'chained' && isChainBreaker(node.parent.parent, version);\n            return (isBeforeChainBreaker ? node.parent.parent : node).parent.type !== 'ExpressionStatement';\n        }\n\n        function isPureLodashCollectionMethod(method, version) {\n            return isCollectionMethod(version, method) && !isAliasOfMethod(version, 'remove', method);\n        }\n\n        function isSideEffectIterationMethod(method, version) {\n            return includes(getSideEffectIterationMethods(version), method);\n        }\n\n        function isParentCommit(node, callType, version) {\n            return callType === 'chained' && isCallToMethod(node.parent.parent, version, 'commit');\n        }\n\n        return getLodashMethodVisitors(context, function (node, iteratee, _ref) {\n            var method = _ref.method,\n                version = _ref.version,\n                callType = _ref.callType;\n\n            if (isPureLodashCollectionMethod(method, version) && !parentUsesValue(node, callType, version)) {\n                context.report(node, 'Use value returned from _.' + method);\n            } else if (isSideEffectIterationMethod(method, version) && parentUsesValue(node, callType, version) && !isParentCommit(node, callType, version)) {\n                context.report(node, 'Do not use value returned from _.' + getMethodName(node));\n            }\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/collection-return.js":"/**\n * @fileoverview Rule to check that iteratees for all collection functions except forEach return a value;\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check that iteratees for all collection functions except forEach return a value;\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashMethodCallExpVisitor = _require.getLodashMethodCallExpVisitor,\n            getLodashContext = _require.getLodashContext;\n\n        var _require2 = require('../util/methodDataUtil'),\n            isCollectionMethod = _require2.isCollectionMethod;\n\n        var _require3 = require('../util/astUtil'),\n            isFunctionDefinitionWithBlock = _require3.isFunctionDefinitionWithBlock;\n\n        var assign = require('lodash/assign');\n        var funcInfos = new Map();\n        var currFuncInfo = {};\n        var lodashContext = getLodashContext(context);\n        return assign({\n            'CallExpression:exit': getLodashMethodCallExpVisitor(lodashContext, function (node, iteratee, _ref) {\n                var method = _ref.method,\n                    version = _ref.version;\n\n                if (isCollectionMethod(version, method) && funcInfos.has(iteratee)) {\n                    var _funcInfos$get = funcInfos.get(iteratee),\n                        hasReturn = _funcInfos$get.hasReturn;\n\n                    if (isFunctionDefinitionWithBlock(iteratee) && !hasReturn && !iteratee.async) {\n                        context.report(node, 'Do not use _.' + method + ' without returning a value');\n                    }\n                }\n            }),\n            ReturnStatement: function ReturnStatement() {\n                currFuncInfo.hasReturn = true;\n            },\n            onCodePathStart: function onCodePathStart(codePath, node) {\n                currFuncInfo = {\n                    upper: currFuncInfo,\n                    codePath: codePath,\n                    hasReturn: false\n                };\n                funcInfos.set(node, currFuncInfo);\n            },\n            onCodePathEnd: function onCodePathEnd() {\n                currFuncInfo = currFuncInfo.upper;\n            }\n        }, lodashContext.getImportVisitors());\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/consistent-compose.js":"/**\n * @fileoverview Rule to enforce a consistent composition method\n */\n'use strict';\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nvar possibleDirections = ['pipe', 'compose', 'flow', 'flowRight'];\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            enum: possibleDirections\n        }]\n    },\n\n    create: function create(context) {\n        var includes = require('lodash/includes');\n\n        var _require = require('../util/lodashUtil'),\n            getLodashMethodVisitors = _require.getLodashMethodVisitors;\n\n        var _require$getSettings = require('../util/settingsUtil').getSettings(context),\n            version = _require$getSettings.version;\n\n        var _require2 = require('../util/methodDataUtil'),\n            getMainAlias = _require2.getMainAlias;\n\n        var direction = context.options[0] || 'flow';\n        var mainDirectionMethod = getMainAlias(version, direction);\n\n        function isOtherDirection(method) {\n            if (includes(possibleDirections, method)) {\n                var methodDirection = getMainAlias(version, method);\n                return methodDirection !== mainDirectionMethod;\n            }\n        }\n\n        return getLodashMethodVisitors(context, function (node, iteratee, _ref) {\n            var method = _ref.method;\n\n            if (isOtherDirection(method)) {\n                context.report(node, 'Use _.' + direction + ' for composition');\n            }\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/identity-shorthand.js":"/**\n * @fileoverview Rule to check if the identity shorthand can be used\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if the identity shorthand can be used\n */\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            enum: ['always', 'never']\n        }]\n    },\n\n    create: function create(context) {\n        var get = require('lodash/get');\n        var matches = require('lodash/matches');\n        var overSome = require('lodash/overSome');\n\n        var _require = require('../util/methodDataUtil'),\n            methodSupportsShorthand = _require.methodSupportsShorthand;\n\n        var _require2 = require('../util/lodashUtil'),\n            getShorthandVisitors = _require2.getShorthandVisitors;\n\n        var _require3 = require('../util/astUtil'),\n            getFirstParamName = _require3.getFirstParamName,\n            getValueReturnedInFirstStatement = _require3.getValueReturnedInFirstStatement;\n\n        var settings = require('../util/settingsUtil').getSettings(context);\n\n        function isExplicitIdentityFunction(iteratee) {\n            var firstParamName = getFirstParamName(iteratee);\n            return firstParamName && get(getValueReturnedInFirstStatement(iteratee), 'name') === firstParamName;\n        }\n\n        var isLodashIdentityFunction = matches({\n            type: 'MemberExpression',\n            object: { name: settings.pragma },\n            property: { name: 'identity' }\n        });\n\n        var canUseShorthand = overSome(isExplicitIdentityFunction, isLodashIdentityFunction);\n\n        function usesShorthand(node, iteratee, method) {\n            return methodSupportsShorthand(settings.version, method) && !iteratee;\n        }\n\n        return getShorthandVisitors(context, {\n            canUseShorthand: canUseShorthand,\n            usesShorthand: usesShorthand\n        }, {\n            always: 'Prefer omitting the iteratee over a function that returns its argument',\n            never: 'Do not use the identity shorthand syntax'\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/import-scope.js":"/**\n * @fileoverview Rule to disallow the use of a chain for a single method\n */\n'use strict';\n\n/**\n * @fileoverview Rule to disallow the use of a chain for a single method\n */\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nvar _require = require('../util/importUtil'),\n    isFullLodashImport = _require.isFullLodashImport,\n    getNameFromCjsRequire = _require.getNameFromCjsRequire,\n    getMethodImportFromName = _require.getMethodImportFromName;\n\nvar every = require('lodash/every');\nvar includes = require('lodash/includes');\n\nvar messages = {\n    method: 'Do not import from the full Lodash module.',\n    member: 'Import members from the full Lodash module.',\n    full: 'Use the full Lodash module.'\n};\n\nvar importNodeTypes = {\n    method: ['ImportDefaultSpecifier'],\n    member: ['ImportSpecifier'],\n    full: ['ImportDefaultSpecifier', 'ImportNamespaceSpecifier']\n};\n\nvar isMethodImport = function isMethodImport(name) {\n    return Boolean(getMethodImportFromName(name));\n};\nvar allImportsAreOfType = function allImportsAreOfType(node, types) {\n    return every(node.specifiers, function (specifier) {\n        return includes(types, specifier.type);\n    });\n};\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            enum: ['method', 'member', 'full']\n        }]\n    },\n    create: function create(context) {\n        var importType = context.options[0] || 'method';\n\n        return {\n            ImportDeclaration: function ImportDeclaration(node) {\n                if (isFullLodashImport(node.source.value)) {\n                    if (importType === 'method') {\n                        context.report(node, messages.method);\n                    } else {\n                        if (!allImportsAreOfType(node, importNodeTypes[importType])) {\n                            context.report(node, messages[importType]);\n                        }\n                    }\n                } else if (isMethodImport(node.source.value) && importType !== 'method') {\n                    context.report(node, messages[importType]);\n                }\n            },\n            VariableDeclarator: function VariableDeclarator(node) {\n                var name = getNameFromCjsRequire(node.init);\n                if (isFullLodashImport(name)) {\n                    if (importType === 'method') {\n                        context.report(node, messages.method);\n                    } else {\n                        var isObjectPattern = node.id.type === 'ObjectPattern';\n                        var isMemberImport = importType === 'member';\n                        if (isObjectPattern !== isMemberImport) {\n                            context.report(node, messages[importType]);\n                        }\n                    }\n                } else if (isMethodImport(name) && importType !== 'method') {\n                    context.report(node, messages[importType]);\n                }\n            }\n        };\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/util/importUtil.js":"'use strict';\n\nvar get = require('lodash/get');\n\nfunction getNameFromCjsRequire(init) {\n    if (get(init, 'callee.name') === 'require' && get(init, 'arguments.length') === 1 && init.arguments[0].type === 'Literal') {\n        return init.arguments[0].value;\n    }\n}\n\nvar isFullLodashImport = function isFullLodashImport(str) {\n    return (/^lodash(-es)?$/.test(str)\n    );\n};\nvar getMethodImportFromName = function getMethodImportFromName(str) {\n    var match = /^lodash(-es)?\\/(?!fp)(\\w+)$/.exec(str);\n    return match && match[2];\n};\n\nmodule.exports = {\n    getNameFromCjsRequire: getNameFromCjsRequire, isFullLodashImport: isFullLodashImport, getMethodImportFromName: getMethodImportFromName\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/matches-prop-shorthand.js":"/**\n * @fileoverview Rule to check if the macthesProperty shorthand can be used\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if the macthesProperty shorthand can be used\n */\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            enum: ['always', 'never']\n        }, {\n            type: 'object',\n            properties: {\n                onlyLiterals: {\n                    type: 'boolean'\n                }\n            }\n        }]\n    },\n\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            isCallToLodashMethod = _require.isCallToLodashMethod,\n            getShorthandVisitors = _require.getShorthandVisitors;\n\n        var _require2 = require('../util/astUtil'),\n            isEqEqEqToMemberOf = _require2.isEqEqEqToMemberOf,\n            getValueReturnedInFirstStatement = _require2.getValueReturnedInFirstStatement,\n            getFirstParamName = _require2.getFirstParamName;\n\n        var _require$getSettings = require('../util/settingsUtil').getSettings(context),\n            version = _require$getSettings.version;\n\n        var onlyLiterals = context.options[1] && context.options[1].onlyLiterals;\n\n        function isFunctionDeclarationThatCanUseShorthand(func) {\n            return isEqEqEqToMemberOf(getValueReturnedInFirstStatement(func), getFirstParamName(func), { onlyLiterals: onlyLiterals });\n        }\n\n        function canUseShorthand(iteratee, lodashContext) {\n            return isFunctionDeclarationThatCanUseShorthand(iteratee) || isCallToLodashMethod(iteratee, 'matchesProperty', lodashContext);\n        }\n\n        function callHasExtraParamAfterIteratee(node, iteratee) {\n            return node.arguments[node.arguments.indexOf(iteratee) + 1];\n        }\n\n        var matchesPropertyChecks = {\n            3: function _(node, iteratee) {\n                return iteratee && iteratee.type === 'Literal' && callHasExtraParamAfterIteratee(node, iteratee);\n            },\n            4: function _(node, iteratee) {\n                return iteratee && iteratee.type === 'ArrayExpression';\n            }\n        };\n\n        return getShorthandVisitors(context, {\n            canUseShorthand: canUseShorthand,\n            usesShorthand: matchesPropertyChecks[version]\n        }, {\n            always: 'Prefer matches property syntax',\n            never: 'Do not use matches property syntax'\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/matches-shorthand.js":"/**\n * @fileoverview Rule to check if the matches shorthand can be used\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if the matches shorthand can be used\n */\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            enum: ['always', 'never']\n        }, {\n            type: 'integer',\n            minimum: 1\n        }, {\n            type: 'boolean'\n        }, {\n            type: 'object',\n            properties: {\n                onlyLiterals: {\n                    type: 'boolean'\n                }\n            }\n        }]\n    },\n\n    create: function create(context) {\n        var matches = require('lodash/matches');\n\n        var _require = require('../util/lodashUtil'),\n            isCallToLodashMethod = _require.isCallToLodashMethod,\n            getShorthandVisitors = _require.getShorthandVisitors;\n\n        var _require2 = require('../util/astUtil'),\n            isEqEqEq = _require2.isEqEqEq,\n            isMemberExpOf = _require2.isMemberExpOf,\n            isEqEqEqToMemberOf = _require2.isEqEqEqToMemberOf,\n            getValueReturnedInFirstStatement = _require2.getValueReturnedInFirstStatement,\n            getFirstParamName = _require2.getFirstParamName;\n\n        var _require3 = require('../util/settingsUtil'),\n            isEcmaFeatureOn = _require3.isEcmaFeatureOn;\n\n        var DEFAULT_MAX_PROPERTY_PATH_LENGTH = 3;\n        var onlyLiterals = context.options[3] && context.options[3].onlyLiterals;\n\n        var isConjunction = matches({ type: 'LogicalExpression', operator: '&&' });\n\n        function canBeObjectLiteralWithShorthandProperty(node, paramName) {\n            return isEcmaFeatureOn(context, 'objectLiteralShorthandProperties') && isEqEqEq(node) && (isMemberExpOf(node.left, paramName, { maxLength: 1 }) && node.left.property.type === 'Identifier' && node.right.type === 'Identifier' && node.left.property.name === node.right.name || isMemberExpOf(node.right, paramName, { maxLength: 1 }) && node.right.property.type === 'Identifier' && node.left.type === 'Identifier' && node.right.property.name === node.left.name);\n        }\n\n        function isConjunctionOfEqEqEqToMemberOf(exp, paramName, maxLength) {\n            var allowComputed = context.options[2] && isEcmaFeatureOn(context, 'objectLiteralComputedProperties');\n            if (isConjunction(exp) || canBeObjectLiteralWithShorthandProperty(exp, paramName)) {\n                var checkStack = [exp];\n                var curr = void 0;\n                var allParamMemberEq = true;\n                curr = checkStack.pop();\n                while (curr) {\n                    if (isConjunction(curr)) {\n                        checkStack.push(curr.left, curr.right);\n                    } else if (!isEqEqEqToMemberOf(curr, paramName, { maxLength: maxLength, allowComputed: allowComputed, onlyLiterals: onlyLiterals })) {\n                        allParamMemberEq = false;\n                    }\n                    curr = checkStack.pop();\n                }\n                return allParamMemberEq;\n            }\n        }\n\n        function isFunctionDeclarationThatCanUseShorthand(func) {\n            var maxPropertyPathLength = context.options[1] || DEFAULT_MAX_PROPERTY_PATH_LENGTH;\n            return isConjunctionOfEqEqEqToMemberOf(getValueReturnedInFirstStatement(func), getFirstParamName(func), maxPropertyPathLength);\n        }\n\n        function canUseShorthand(iteratee, lodashContext) {\n            return isFunctionDeclarationThatCanUseShorthand(iteratee) || isCallToLodashMethod(iteratee, 'matches', lodashContext);\n        }\n\n        function usesShorthand(node, iteratee) {\n            return iteratee && iteratee.type === 'ObjectExpression';\n        }\n\n        return getShorthandVisitors(context, {\n            canUseShorthand: canUseShorthand,\n            usesShorthand: usesShorthand\n        }, {\n            always: 'Prefer matches syntax',\n            never: 'Do not use matches syntax'\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/no-commit.js":"/**\n * @fileoverview Rule to disallow using _.prototype.commit.\n */\n'use strict';\n\n/**\n * @fileoverview Rule to disallow using _.prototype.commit.\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashContext = _require.getLodashContext,\n            isCallToMethod = _require.isCallToMethod;\n\n        var _require2 = require('../util/astUtil'),\n            isMethodCall = _require2.isMethodCall;\n\n        var lodashContext = getLodashContext(context);\n        var visitors = lodashContext.getImportVisitors();\n        visitors.CallExpression = function (node) {\n            if (lodashContext.isLodashChainStart(node)) {\n                do {\n                    node = node.parent.parent;\n                } while (isMethodCall(node) && !isCallToMethod(node, lodashContext.version, 'commit'));\n                if (isCallToMethod(node, lodashContext.version, 'commit')) {\n                    context.report(node, 'Do not end chain with commit.');\n                }\n            }\n        };\n        return visitors;\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/no-double-unwrap.js":"/**\n * @fileoverview Rule to make sure value() wasn't called on a lodash chain twice\n */\n'use strict';\n\n/**\n * @fileoverview Rule to make sure value() wasn't called on a lodash chain twice\n */\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        fixable: \"code\"\n    },\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashContext = _require.getLodashContext,\n            isChainBreaker = _require.isChainBreaker,\n            isChainable = _require.isChainable;\n\n        var _require2 = require('../util/astUtil'),\n            isMethodCall = _require2.isMethodCall,\n            getCaller = _require2.getCaller,\n            getMethodName = _require2.getMethodName;\n\n        var lodashContext = getLodashContext(context);\n        var version = lodashContext.version;\n        var visitors = lodashContext.getImportVisitors();\n        visitors.CallExpression = function (node) {\n            if (lodashContext.isImplicitChainStart(node)) {\n                do {\n                    node = node.parent.parent;\n                } while (isMethodCall(node) && !isChainBreaker(node, version));\n                var caller = getCaller(node);\n                if (isMethodCall(node) && !isChainable(caller, version)) {\n                    context.report({\n                        node: node,\n                        message: 'Do not use .value() after chain-ending method {{method}}',\n                        data: { method: getMethodName(caller) },\n                        fix: function fix(fixer) {\n                            return fixer.removeRange([caller.range[1], node.range[1]]);\n                        }\n                    });\n                }\n            }\n        };\n        return visitors;\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/no-extra-args.js":"/**\n * @fileoverview Rule to make sure lodash method calls don't use superfluous arguments\n */\n'use strict';\n\n/**\n * @fileoverview Rule to make sure lodash method calls don't use superfluous arguments\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require$getSettings = require('../util/settingsUtil').getSettings(context),\n            version = _require$getSettings.version;\n\n        var _require = require('../util/lodashUtil'),\n            getLodashMethodVisitors = _require.getLodashMethodVisitors;\n\n        var _require2 = require('../util/methodDataUtil'),\n            getFunctionMaxArity = _require2.getFunctionMaxArity;\n\n        function getExpectedArity(callType, method) {\n            var maxArity = getFunctionMaxArity(version, method);\n            return Math.max(callType === 'chained' ? maxArity - 1 : maxArity, 0);\n        }\n\n        return getLodashMethodVisitors(context, function (node, iteratee, _ref) {\n            var callType = _ref.callType,\n                method = _ref.method;\n\n            var expectedArity = getExpectedArity(callType, method);\n            if (node.arguments.length > expectedArity) {\n                context.report({\n                    node: node,\n                    message: 'Too many arguments passed to `{{method}}` (expected {{expectedArity}}).',\n                    data: { method: method, expectedArity: expectedArity }\n                });\n            }\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/no-single-chain.js":"/**\n * @fileoverview Rule to disallow the use of a chain for a single method\n */\n'use strict';\n\n/**\n * @fileoverview Rule to disallow the use of a chain for a single method\n */\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/lodashUtil');\n\n        var isChainBreaker = _require.isChainBreaker;\n        var isLodashChainStart = _require.isLodashChainStart;\n        var getLodashImportVisitors = _require.getLodashImportVisitors;\n\n        var _require2 = require('../util/astUtil');\n\n        var isObjectOfMethodCall = _require2.isObjectOfMethodCall;\n        var isMethodCall = _require2.isMethodCall;\n\n        var _require$getSettings = require('../util/settingsUtil').getSettings(context);\n\n        var version = _require$getSettings.version;\n        var pragma = _require$getSettings.pragma;\n\n        var _require3 = require('../util/ruleUtil');\n\n        var combineVisitorObjects = _require3.combineVisitorObjects;\n\n        var negate = require('lodash/negate');\n\n        var isEndOfChain = negate(isObjectOfMethodCall);\n\n        function isBeforeChainBreaker(node) {\n            return isChainBreaker(node.parent.parent, version);\n        }\n\n        return combineVisitorObjects({\n            CallExpression: function CallExpression(node) {\n                if (isLodashChainStart(node, pragma)) {\n                    var firstCall = node.parent.parent;\n                    if (isMethodCall(firstCall) && (isEndOfChain(firstCall) || isBeforeChainBreaker(firstCall))) {\n                        context.report(firstCall, 'Do not use chain syntax for single method');\n                    }\n                }\n            }\n        }, getLodashImportVisitors(context));\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/no-unbound-this.js":"/**\n * @fileoverview Rule to check that all uses of `this` inside collection methods are bound\n */\n'use strict';\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashMethodCallExpVisitor = _require.getLodashMethodCallExpVisitor,\n            getLodashContext = _require.getLodashContext;\n\n        var _require2 = require('../util/methodDataUtil'),\n            isCollectionMethod = _require2.isCollectionMethod;\n\n        var _require3 = require('../util/astUtil'),\n            isFunctionExpression = _require3.isFunctionExpression;\n\n        var assign = require('lodash/assign');\n        var funcInfos = new Map();\n        var currFuncInfo = {\n            thisUses: []\n        };\n        var lodashContext = getLodashContext(context);\n        return assign({\n            'CallExpression:exit': getLodashMethodCallExpVisitor(lodashContext, function (node, iteratee, _ref) {\n                var method = _ref.method,\n                    version = _ref.version;\n\n                if ((isCollectionMethod(version, method) || /^forEach(Right)?$/.test(method)) && funcInfos.has(iteratee)) {\n                    var _funcInfos$get = funcInfos.get(iteratee),\n                        thisUses = _funcInfos$get.thisUses;\n\n                    if (isFunctionExpression(iteratee) && thisUses.length) {\n                        thisUses.forEach(function (thisNode) {\n                            context.report(thisNode, 'Do not use `this` without binding in collection methods');\n                        });\n                    }\n                }\n            }),\n            ThisExpression: function ThisExpression(node) {\n                currFuncInfo.thisUses.push(node);\n            },\n            onCodePathStart: function onCodePathStart(codePath, node) {\n                currFuncInfo = {\n                    upper: currFuncInfo,\n                    codePath: codePath,\n                    thisUses: []\n                };\n                funcInfos.set(node, currFuncInfo);\n            },\n            onCodePathEnd: function onCodePathEnd() {\n                currFuncInfo = currFuncInfo.upper;\n            }\n        }, lodashContext.getImportVisitors());\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/path-style.js":"/**\n * @fileoverview Rule to check if there's a JS native method in the lodash chain\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if there's a JS native method in the lodash chain\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            enum: ['as-needed', 'array', 'string']\n        }]\n    },\n\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashMethodVisitors = _require.getLodashMethodVisitors;\n\n        var _require2 = require('../util/methodDataUtil'),\n            isAliasOfMethod = _require2.isAliasOfMethod;\n\n        var objectPathMethods = {\n            regular: { methods: ['get', 'has', 'hasIn', 'set', 'unset', 'invoke'], index: 1 },\n            higherOrder: { methods: ['property', 'matchesProperty'], index: 0 }\n        };\n        var find = require('lodash/find');\n        var findIndex = require('lodash/findIndex');\n        var some = require('lodash/some');\n        var every = require('lodash/every');\n        var get = require('lodash/get');\n        var matches = require('lodash/matches');\n        var isPropAccess = function isPropAccess(x) {\n            return x === '.' || x === '[';\n        };\n\n        function endsWithPropAccess(str) {\n            return isPropAccess(str[str.length - 1]);\n        }\n\n        function startsWithPropAccess(str) {\n            return isPropAccess(str[0]);\n        }\n\n        function getIndexByMethodName(method, version) {\n            var isAliasOfSuspect = function isAliasOfSuspect(m) {\n                return isAliasOfMethod(version, m, method);\n            };\n            var pathMethodGroup = find(objectPathMethods, function (type) {\n                return some(type.methods, isAliasOfSuspect);\n            });\n            return pathMethodGroup ? pathMethodGroup.index : -1;\n        }\n\n        function getPropertyPathNode(node, method, version, callType) {\n            var index = getIndexByMethodName(method, version);\n            return node.arguments[callType === 'chained' ? index - 1 : index];\n        }\n\n        var isArrayExpression = matches({ type: 'ArrayExpression' });\n        var isLiteral = matches({ type: 'Literal' });\n        var isAddition = matches({ type: 'BinaryExpression', operator: '+' });\n        var isTemplateLiteral = matches({ type: 'TemplateLiteral' });\n\n        function isArrayOfLiterals(node) {\n            return isArrayExpression(node) && every(node.elements, isLiteral);\n        }\n\n        function isAdjacentToPropAccessInTemplate(exp, literal) {\n            var quasiAfterIndex = findIndex(literal.quasis, function (quasi) {\n                return quasi.start > exp.end;\n            });\n            var quasiBefore = literal.quasis[quasiAfterIndex - 1];\n            var quasiAfter = literal.quasis[quasiAfterIndex];\n            return quasiBefore && endsWithPropAccess(quasiBefore.value.raw) || quasiAfter && startsWithPropAccess(quasiAfter.value.raw);\n        }\n\n        function isTemplateStringWithVariableProps(node) {\n            return isTemplateLiteral(node) && some(node.expressions, function (exp) {\n                return isAdjacentToPropAccessInTemplate(exp, node);\n            });\n        }\n\n        function isStringConcatWithVariableProps(node) {\n            return isAddition(node) && (isLiteral(node.left) && endsWithPropAccess(node.left.value) || isLiteral(node.right) && startsWithPropAccess(node.right.value));\n        }\n\n        function isPathStringWithVariableProps(node) {\n            return isTemplateStringWithVariableProps(node) || isStringConcatWithVariableProps(node);\n        }\n\n        var reportIfViolates = {\n            'as-needed': function asNeeded(node) {\n                if (isArrayOfLiterals(node)) {\n                    context.report(node, 'Use a string for simple paths');\n                } else if (isPathStringWithVariableProps(node)) {\n                    context.report(node, 'Use an array for paths with variables');\n                }\n            },\n            array: function array(node) {\n                if (isLiteral(node)) {\n                    context.report(node, 'Use an array for paths');\n                }\n            },\n            string: function string(node) {\n                if (isArrayExpression(node)) {\n                    context.report(node, 'Use a string for paths');\n                }\n            }\n        };\n\n        return getLodashMethodVisitors(context, function (node, iteratee, _ref) {\n            var method = _ref.method,\n                version = _ref.version,\n                callType = _ref.callType;\n\n            var propertyPathNode = getPropertyPathNode(node, method, version, callType);\n            if (propertyPathNode) {\n                reportIfViolates[context.options[0] || 'as-needed'](propertyPathNode);\n            }\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-chain.js":"/**\n * @fileoverview Rule to check if the expression could be better expressed as a chain\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if the expression could be better expressed as a chain\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'integer',\n            minimum: 2\n        }]\n    },\n\n    create: function create(context) {\n        var _require = require('../util/lodashUtil');\n\n        var isLodashCall = _require.isLodashCall;\n        var getLodashImportVisitors = _require.getLodashImportVisitors;\n\n        var _require2 = require('../util/astUtil');\n\n        var getCaller = _require2.getCaller;\n\n        var _require3 = require('../util/ruleUtil');\n\n        var combineVisitorObjects = _require3.combineVisitorObjects;\n\n        var DEFAULT_LENGTH = 3;\n        var settings = require('../util/settingsUtil').getSettings(context);\n        var ruleDepth = parseInt(context.options[0], 10) || DEFAULT_LENGTH;\n\n        function isNestedNLevels(node, n) {\n            return n === 0 || isLodashCall(node, settings.pragma, context) && isNestedNLevels(node.arguments[0], n - 1);\n        }\n\n        return combineVisitorObjects({\n            CallExpression: function CallExpression(node) {\n                if (isNestedNLevels(node, ruleDepth)) {\n                    context.report(getCaller(node.arguments[0]), 'Prefer chaining to composition');\n                }\n            }\n        }, getLodashImportVisitors(context));\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-compact.js":"/**\n * @fileoverview Rule to check if a call to filter should be a call to compact\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if a call to filter should be a call to compact\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashMethodVisitors = _require.getLodashMethodVisitors;\n\n        var _require2 = require('../util/astUtil'),\n            isNegationExpression = _require2.isNegationExpression,\n            isIdentifierWithName = _require2.isIdentifierWithName,\n            getValueReturnedInFirstStatement = _require2.getValueReturnedInFirstStatement,\n            getFirstParamName = _require2.getFirstParamName;\n\n        var _require3 = require('../util/methodDataUtil'),\n            isAliasOfMethod = _require3.isAliasOfMethod;\n\n        function isDoubleNegationOfParam(exp, paramName) {\n            return isNegationExpression(exp) && isNegationExpression(exp.argument) && isIdentifierWithName(exp.argument.argument, paramName);\n        }\n\n        function isCallToBooleanCastOfParam(exp, paramName) {\n            return exp && exp.type === 'CallExpression' && exp.callee.name === 'Boolean' && isIdentifierWithName(exp.arguments[0], paramName);\n        }\n\n        function isBooleanCastingFunction(func) {\n            var returnValue = getValueReturnedInFirstStatement(func);\n            var paramName = getFirstParamName(func);\n            return func && func.type === 'Identifier' && func.name === 'Boolean' || isIdentifierWithName(returnValue, paramName) || isDoubleNegationOfParam(returnValue, paramName) || isCallToBooleanCastOfParam(returnValue, paramName);\n        }\n\n        return getLodashMethodVisitors(context, function (node, iteratee, _ref) {\n            var method = _ref.method,\n                version = _ref.version;\n\n            if (isAliasOfMethod(version, 'filter', method) && isBooleanCastingFunction(iteratee)) {\n                context.report(node, 'Prefer _.compact over filtering of Boolean casting');\n            }\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-constant.js":"/**\n * @fileoverview Rule to check if the expression could be better expressed as a _.constant\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if the expression could be better expressed as a _.constant\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'boolean'\n        }, {\n            type: 'boolean'\n        }]\n    },\n\n    create: function create(context) {\n        var _require = require('../util/astUtil'),\n            getValueReturnedInFirstStatement = _require.getValueReturnedInFirstStatement;\n\n        var shouldCheckArrowFunctions = context.options[0] !== undefined ? context.options[0] : true;\n        var shouldCheckFunctionDeclarations = context.options[1] !== undefined ? context.options[1] : false;\n\n        function isCompletelyLiteral(node) {\n            switch (node.type) {\n                case 'Literal':\n                    return true;\n                case 'BinaryExpression':\n                    return isCompletelyLiteral(node.left) && isCompletelyLiteral(node.right);\n                case 'UnaryExpression':\n                    return isCompletelyLiteral(node.argument);\n                case 'ConditionalExpression':\n                    return isCompletelyLiteral(node.test) && isCompletelyLiteral(node.consequent) && isCompletelyLiteral(node.alternate);\n                default:\n                    return false;\n            }\n        }\n\n        function reportIfLikeConstant(func, node) {\n            var valueReturnedInFirstLine = func(node);\n            if (valueReturnedInFirstLine && isCompletelyLiteral(valueReturnedInFirstLine)) {\n                context.report(node, 'Prefer _.constant over a function returning a literal');\n            }\n        }\n\n        function handleFunctionDefinition(node) {\n            reportIfLikeConstant(getValueReturnedInFirstStatement, node);\n        }\n\n        return {\n            FunctionExpression: handleFunctionDefinition,\n            FunctionDeclaration: function FunctionDeclaration(node) {\n                if (shouldCheckFunctionDeclarations) {\n                    handleFunctionDefinition(node);\n                }\n            },\n            ArrowFunctionExpression: function ArrowFunctionExpression(node) {\n                if (shouldCheckArrowFunctions) {\n                    handleFunctionDefinition(node);\n                }\n            }\n        };\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-filter.js":"/**\n * @fileoverview Rule to check if a call to _.forEach should be a call to _.filter\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if a call to _.forEach should be a call to _.filter\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'integer'\n        }]\n    },\n\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashMethodVisitors = _require.getLodashMethodVisitors;\n\n        var _require2 = require('../util/astUtil'),\n            isIdentifierWithName = _require2.isIdentifierWithName,\n            isMemberExpOf = _require2.isMemberExpOf,\n            isNegationOfMemberOf = _require2.isNegationOfMemberOf,\n            isEqEqEqToMemberOf = _require2.isEqEqEqToMemberOf,\n            isNotEqEqToMemberOf = _require2.isNotEqEqToMemberOf,\n            getFirstFunctionLine = _require2.getFirstFunctionLine,\n            hasOnlyOneStatement = _require2.hasOnlyOneStatement,\n            getFirstParamName = _require2.getFirstParamName;\n\n        var _require3 = require('../util/methodDataUtil'),\n            isAliasOfMethod = _require3.isAliasOfMethod;\n\n        var DEFAULT_MAX_PROPERTY_PATH_LENGTH = 3;\n        var maxLength = parseInt(context.options[0], 10) || DEFAULT_MAX_PROPERTY_PATH_LENGTH;\n\n        function isIfWithoutElse(statement) {\n            return statement && statement.type === 'IfStatement' && !statement.alternate;\n        }\n\n        function canBeShorthand(exp, paramName) {\n            return isIdentifierWithName(exp, paramName) || isMemberExpOf(exp, paramName, { maxLength: maxLength }) || isNegationOfMemberOf(exp, paramName, { maxLength: maxLength }) || isEqEqEqToMemberOf(exp, paramName, { maxLength: maxLength }) || isNotEqEqToMemberOf(exp, paramName, { maxLength: maxLength });\n        }\n\n        function onlyHasSimplifiableIf(func) {\n            var firstLine = getFirstFunctionLine(func);\n            return func && hasOnlyOneStatement(func) && func.params.length === 1 && isIfWithoutElse(firstLine) && canBeShorthand(firstLine.test, getFirstParamName(func));\n        }\n\n        return getLodashMethodVisitors(context, function (node, iteratee, _ref) {\n            var method = _ref.method,\n                version = _ref.version;\n\n            if (isAliasOfMethod(version, 'forEach', method) && onlyHasSimplifiableIf(iteratee)) {\n                context.report(node, 'Prefer _.filter or _.some over an if statement inside a _.forEach');\n            }\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-flat-map.js":"/**\n * @fileoverview Rule to check if a call to map and flatten should be a call to _.flatMap\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if a call to map and flatten should be a call to _.flatMap\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashMethodVisitors = _require.getLodashMethodVisitors,\n            isCallToMethod = _require.isCallToMethod,\n            isCallToLodashMethod = _require.isCallToLodashMethod;\n\n        var _require2 = require('../util/astUtil'),\n            getCaller = _require2.getCaller;\n\n        var _require3 = require('../util/methodDataUtil'),\n            isAliasOfMethod = _require3.isAliasOfMethod;\n\n        function isChainedMapFlatten(callType, node, version) {\n            return callType === 'chained' && isCallToMethod(getCaller(node), version, 'map');\n        }\n\n        return getLodashMethodVisitors(context, function (node, iteratee, _ref) {\n            var method = _ref.method,\n                version = _ref.version,\n                callType = _ref.callType,\n                lodashContext = _ref.lodashContext;\n\n            if (isAliasOfMethod(version, 'flatten', method) && (isChainedMapFlatten(callType, node, version) || isCallToLodashMethod(node.arguments[0], 'map', lodashContext))) {\n                context.report(node, 'Prefer _.flatMap over consecutive map and flatten.');\n            }\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-get.js":"/**\n * @fileoverview Rule to check if an \"&&\" experssion should be a call to _.get or _.has\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if an \"&&\" experssion should be a call to _.get or _.has\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'integer',\n            minimum: 2\n        }]\n    },\n\n    create: function create(context) {\n        var DEFAULT_LENGTH = 3;\n\n        var _require = require('../util/astUtil'),\n            isComputed = _require.isComputed,\n            isEquivalentMemberExp = _require.isEquivalentMemberExp,\n            isEqEqEq = _require.isEqEqEq;\n\n        var ruleDepth = parseInt(context.options[0], 10) || DEFAULT_LENGTH;\n\n        var expStates = [];\n        function getState() {\n            return expStates[expStates.length - 1] || { depth: 0 };\n        }\n\n        function shouldCheckDeeper(node, nodeRight, toCompare) {\n            return node.operator === '&&' && nodeRight && nodeRight.type === 'MemberExpression' && !isComputed(nodeRight) && (!toCompare || isEquivalentMemberExp(nodeRight, toCompare));\n        }\n\n        return {\n            LogicalExpression: function LogicalExpression(node) {\n                var state = getState();\n                var rightMemberExp = isEqEqEq(node.right) && state.depth === 0 ? node.right.left : node.right;\n\n                if (shouldCheckDeeper(node, rightMemberExp, state.node)) {\n                    expStates.push({ depth: state.depth + 1, node: rightMemberExp.object });\n                    if (isEquivalentMemberExp(node.left, rightMemberExp.object) && state.depth >= ruleDepth - 2) {\n                        context.report(node, \"Prefer _.get or _.has over an '&&' chain\");\n                    }\n                }\n            },\n            'LogicalExpression:exit': function LogicalExpressionExit(node) {\n                var state = getState();\n                if (state && state.node === node.right.object) {\n                    expStates.pop();\n                }\n            }\n        };\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-includes.js":"/**\n * @fileoverview Rule to check if an indexOfComparison should be a call to _.includes\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if an indexOfComparison should be a call to _.includes\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'object',\n            properties: {\n                includeNative: {\n                    type: 'boolean'\n                }\n            }\n        }]\n    },\n\n    create: function create(context) {\n        var includeNative = context.options[0] && context.options[0].includeNative;\n\n        var _require = require('../util/astUtil'),\n            getExpressionComparedToInt = _require.getExpressionComparedToInt,\n            isIndexOfCall = _require.isIndexOfCall;\n\n        var _require2 = require('../util/lodashUtil'),\n            getLodashMethodVisitors = _require2.getLodashMethodVisitors;\n\n        var _require3 = require('../util/methodDataUtil'),\n            isAliasOfMethod = _require3.isAliasOfMethod;\n\n        var visitors = getLodashMethodVisitors(context, function (node, iteratee, _ref) {\n            var method = _ref.method,\n                version = _ref.version;\n\n            if (isAliasOfMethod(version, 'indexOf', method) && node === getExpressionComparedToInt(node.parent, -1, true)) {\n                context.report(node, 'Prefer _.includes over indexOf comparison to -1');\n            }\n        });\n        if (includeNative) {\n            visitors.BinaryExpression = function (node) {\n                if (isIndexOfCall(getExpressionComparedToInt(node, -1, true))) {\n                    context.report(node, 'Prefer _.includes over indexOf comparison to -1');\n                }\n            };\n        }\n        return visitors;\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-invoke-map.js":"/**\n * @fileoverview Rule to check if a call to map should be a call to invokeMap\n */\n'use strict';\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {}\n    },\n\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashMethodVisitors = _require.getLodashMethodVisitors;\n\n        var _require2 = require('../util/astUtil'),\n            isCallFromObject = _require2.isCallFromObject,\n            getValueReturnedInFirstStatement = _require2.getValueReturnedInFirstStatement,\n            getFirstParamName = _require2.getFirstParamName;\n\n        var _require3 = require('../util/methodDataUtil'),\n            isAliasOfMethod = _require3.isAliasOfMethod;\n\n        function isOnlyUsedForObject(func, firstParamName) {\n            var declaredVariables = context.eslint.getDeclaredVariables(func);\n            return declaredVariables.every(function (variable) {\n                return variable.references.length === 0 || variable.name === firstParamName && variable.references.length === 1;\n            });\n        }\n\n        function isFunctionMethodCallOfParam(func) {\n            var firstParamName = getFirstParamName(func);\n            return firstParamName && isCallFromObject(getValueReturnedInFirstStatement(func), firstParamName) && isOnlyUsedForObject(func, firstParamName);\n        }\n\n        return getLodashMethodVisitors(context, function (node, iteratee, _ref) {\n            var method = _ref.method,\n                version = _ref.version;\n\n            if (isAliasOfMethod(version, 'map', method) && isFunctionMethodCallOfParam(iteratee)) {\n                context.report(node, 'Prefer _.invokeMap over map to a method call.');\n            }\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-is-nil.js":"/**\n * @fileoverview Rule to prefer _.noop over an empty function\n */\n'use strict';\n\n/**\n * @fileoverview Rule to prefer _.noop over an empty function\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/astUtil'),\n            isNegationExpression = _require.isNegationExpression,\n            isEquivalentMemberExp = _require.isEquivalentMemberExp;\n\n        var _require2 = require('../util/lodashUtil'),\n            isCallToLodashMethod = _require2.isCallToLodashMethod,\n            getLodashContext = _require2.getLodashContext;\n\n        var _ = require('lodash');\n        var lodashContext = getLodashContext(context);\n        var nilChecks = {\n            null: {\n                isValue: _.matches({ type: 'Literal', value: null }),\n                expressionChecks: [getLodashTypeCheckedBy('isNull'), getValueComparedTo('null')]\n            },\n            undefined: {\n                isValue: _.matches({ type: 'Identifier', name: 'undefined' }),\n                expressionChecks: [getLodashTypeCheckedBy('isUndefined'), getValueComparedTo('undefined'), getValueWithTypeofUndefinedComparison]\n            }\n        };\n\n        function getLodashTypeCheckedBy(typecheck) {\n            return function (node) {\n                return isCallToLodashMethod(node, typecheck, lodashContext) && node.arguments[0];\n            };\n        }\n\n        function getValueComparedTo(nil) {\n            return function (node, operator) {\n                return node.type === 'BinaryExpression' && node.operator === operator && (nilChecks[nil].isValue(node.right) && node.left || nilChecks[nil].isValue(node.left) && node.right);\n            };\n        }\n\n        var getTypeofArgument = _.cond([[_.matches({ type: 'UnaryExpression', operator: 'typeof' }), _.property('argument')]]);\n\n        var isUndefinedString = _.matches({ type: 'Literal', value: 'undefined' });\n\n        function getValueWithTypeofUndefinedComparison(node, operator) {\n            return node.type === 'BinaryExpression' && node.operator === operator && (isUndefinedString(node.right) && getTypeofArgument(node.left) || isUndefinedString(node.left) && getTypeofArgument(node.right));\n        }\n\n        function checkExpression(nil, operator, node) {\n            return _(nilChecks[nil].expressionChecks).map(function (check) {\n                return check(node, operator);\n            }).find();\n        }\n\n        function checkNegatedExpression(nil, node) {\n            return isNegationExpression(node) && checkExpression(nil, '===', node.argument) || checkExpression(nil, '!==', node);\n        }\n\n        function isEquivalentExistingExpression(node, leftNil, rightNil) {\n            var leftExp = checkExpression(leftNil, '===', node.left);\n            return leftExp && isEquivalentMemberExp(leftExp, checkExpression(rightNil, '===', node.right));\n        }\n\n        function isEquivalentExistingNegation(node, leftNil, rightNil) {\n            var leftExp = checkNegatedExpression(leftNil, node.left);\n            return leftExp && isEquivalentMemberExp(leftExp, checkNegatedExpression(rightNil, node.right));\n        }\n\n        var visitors = lodashContext.getImportVisitors();\n        visitors.LogicalExpression = function (node) {\n            if (node.operator === '||') {\n                if (isEquivalentExistingExpression(node, 'undefined', 'null') || isEquivalentExistingExpression(node, 'null', 'undefined')) {\n                    context.report(node, 'Prefer isNil over checking for undefined or null.');\n                }\n            } else if (isEquivalentExistingNegation(node, 'undefined', 'null') || isEquivalentExistingNegation(node, 'null', 'undefined')) {\n                context.report(node, 'Prefer isNil over checking for undefined or null.');\n            }\n        };\n        return visitors;\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-lodash-chain.js":"/**\n * @fileoverview Rule to check if there's a JS native method in the lodash chain\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if there's a JS native method in the lodash chain\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashContext = _require.getLodashContext,\n            isChainBreaker = _require.isChainBreaker,\n            isNativeCollectionMethodCall = _require.isNativeCollectionMethodCall,\n            isLodashWrapperMethod = _require.isLodashWrapperMethod;\n\n        var _require2 = require('../util/astUtil'),\n            isMethodCall = _require2.isMethodCall,\n            isObjectOfMethodCall = _require2.isObjectOfMethodCall,\n            getMethodName = _require2.getMethodName;\n\n        var REPORT_MESSAGE = \"Do not break chain before method '{{method}}'.\";\n        var lodashContext = getLodashContext(context);\n        var version = lodashContext.version;\n\n        var visitors = lodashContext.getImportVisitors();\n        visitors.CallExpression = function (node) {\n            if (lodashContext.isLodashChainStart(node)) {\n                do {\n                    node = node.parent.parent;\n                } while (isMethodCall(node) && !isChainBreaker(node, version));\n                if (isChainBreaker(node, version) && isObjectOfMethodCall(node)) {\n                    var callAfterChainBreak = node.parent.parent;\n                    if (isNativeCollectionMethodCall(callAfterChainBreak) || isLodashWrapperMethod(callAfterChainBreak, version)) {\n                        context.report({ node: callAfterChainBreak, message: REPORT_MESSAGE, data: { method: getMethodName(callAfterChainBreak) } });\n                    }\n                }\n            } else if (lodashContext.isLodashCall(node)) {\n                if (node.parent.type === 'MemberExpression' && isMethodCall(node.parent.parent) && isNativeCollectionMethodCall(node.parent.parent)) {\n                    context.report({ node: node.parent.parent, message: REPORT_MESSAGE, data: { method: getMethodName(node.parent.parent) } });\n                }\n            }\n        };\n        return visitors;\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-lodash-method.js":"/**\n * @fileoverview Rule to check if there's a method in the chain start that can be in the chain\n */\n'use strict';\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'object',\n            properties: {\n                ignoredMethods: {\n                    type: 'array',\n                    items: {\n                        type: 'string'\n                    }\n                },\n                ignoredObjects: {\n                    type: 'array',\n                    items: {\n                        type: 'string'\n                    }\n                }\n            }\n        }]\n    },\n\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashContext = _require.getLodashContext,\n            isNativeCollectionMethodCall = _require.isNativeCollectionMethodCall,\n            getLodashMethodCallExpVisitor = _require.getLodashMethodCallExpVisitor;\n\n        var _require2 = require('../util/astUtil'),\n            getMethodName = _require2.getMethodName,\n            getCaller = _require2.getCaller;\n\n        var keys = require('lodash/keys');\n        var get = require('lodash/get');\n        var includes = require('lodash/includes');\n        var matches = require('lodash/matches');\n        var some = require('lodash/some');\n        var map = require('lodash/map');\n        var assign = require('lodash/assign');\n        var ignoredMethods = get(context, ['options', 0, 'ignoreMethods'], []);\n        var ignoredObjects = get(context, ['options', 0, 'ignoreObjects'], []);\n        var usingLodash = new Set();\n\n        var nativeStringMap = {\n            endsWith: 'endsWith',\n            includes: 'includes',\n            padEnd: 'padEnd',\n            padStart: 'padStart',\n            repeat: 'repeat',\n            replace: 'replace',\n            split: 'split',\n            startsWith: 'startsWith',\n            toLowerCase: 'toLower',\n            toUpperCase: 'toUpper',\n            trim: 'trim'\n        };\n\n        var lodashContext = getLodashContext(context);\n\n        function isNonNullObjectCreate(callerName, methodName, arg) {\n            return callerName === 'Object' && methodName === 'create' && get(arg, 'value') !== null;\n        }\n\n        function isStaticNativeMethodCall(node) {\n            var staticMethods = {\n                Object: ['assign', 'keys', 'values'],\n                Array: ['isArray']\n            };\n            var callerName = get(node, 'callee.object.name');\n            var methodName = getMethodName(node);\n            return callerName in staticMethods && includes(staticMethods[callerName], methodName) || isNonNullObjectCreate(callerName, methodName, node.arguments[0]);\n        }\n\n        function isNativeStringMethodCall(node) {\n            return includes(keys(nativeStringMap), getMethodName(node));\n        }\n\n        function canUseLodash(node) {\n            return isNativeCollectionMethodCall(node) || isStaticNativeMethodCall(node) || isNativeStringMethodCall(node);\n        }\n\n        function getTextOfNode(node) {\n            if (node) {\n                if (node.type === 'Identifier') {\n                    return node.name;\n                }\n                return context.getSourceCode().getText(node);\n            }\n        }\n\n        function someMatch(patterns, str) {\n            return str && some(patterns, function (pattern) {\n                return str.match(pattern);\n            });\n        }\n\n        function shouldIgnore(node) {\n            return someMatch(ignoredMethods, getMethodName(node)) || someMatch(ignoredObjects, getTextOfNode(getCaller(node)));\n        }\n        return assign({\n            CallExpression: getLodashMethodCallExpVisitor(lodashContext, function (node) {\n                usingLodash.add(node);\n            }),\n            'CallExpression:exit': function CallExpressionExit(node) {\n                if (!usingLodash.has(node) && !shouldIgnore(node) && canUseLodash(node)) {\n                    var lodashMethodName = getMethodName(node);\n                    if (isNativeStringMethodCall(node)) {\n                        lodashMethodName = nativeStringMap[lodashMethodName];\n                    }\n                    context.report(node, 'Prefer \\'_.' + lodashMethodName + '\\' over the native function.');\n                }\n            }\n        }, lodashContext.getImportVisitors());\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-lodash-typecheck.js":"/**\n * @fileoverview Rule to check if there's a method in the chain start that can be in the chain\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if there's a method in the chain start that can be in the chain\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var some = require('lodash/some');\n\n        var _require = require('../util/lodashUtil'),\n            getIsTypeMethod = _require.getIsTypeMethod;\n\n        var otherSides = {\n            left: 'right',\n            right: 'left'\n        };\n\n        function isTypeOf(node) {\n            return node && node.type === 'UnaryExpression' && node.operator === 'typeof';\n        }\n\n        function isStrictComparison(node) {\n            return node.operator === '===' || node.operator === '!==';\n        }\n\n        function isDeclaredVariable(node) {\n            var definedVariables = context.getScope().variables;\n            return some(definedVariables, { name: node.name });\n        }\n\n        function getValueForSide(node, side) {\n            var otherSide = otherSides[side];\n            if (isTypeOf(node[side]) && (node[otherSide].value !== 'undefined' || node[side].argument.type !== 'Identifier' || isDeclaredVariable(node[side].argument))) {\n                return node[otherSide].value;\n            }\n        }\n\n        function getTypeofCompareType(node) {\n            if (isStrictComparison(node)) {\n                return getValueForSide(node, 'left') || getValueForSide(node, 'right');\n            }\n        }\n\n        var REPORT_MESSAGE = 'Prefer \\'_.{{method}}\\' over {{actual}}.';\n\n        return {\n            BinaryExpression: function BinaryExpression(node) {\n                var typeofCompareType = getTypeofCompareType(node);\n                if (typeofCompareType) {\n                    context.report(node, REPORT_MESSAGE, {\n                        method: getIsTypeMethod(typeofCompareType),\n                        actual: '\\'typeof\\' comparison'\n                    });\n                } else if (node.operator === 'instanceof') {\n                    var lodashEquivalent = getIsTypeMethod(node.right.name);\n                    if (node.right.type === 'Identifier' && lodashEquivalent) {\n                        context.report(node, REPORT_MESSAGE, { method: lodashEquivalent, actual: '\\'instanceof ' + node.right.name + '\\'' });\n                    }\n                }\n            }\n        };\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-map.js":"/**\n * @fileoverview Rule to check if a call to _.forEach should be a call to _.filter\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if a call to _.forEach should be a call to _.filter\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashMethodVisitors = _require.getLodashMethodVisitors;\n\n        var _require2 = require('../util/astUtil'),\n            getFirstFunctionLine = _require2.getFirstFunctionLine,\n            hasOnlyOneStatement = _require2.hasOnlyOneStatement,\n            getMethodName = _require2.getMethodName,\n            isFunctionDefinitionWithBlock = _require2.isFunctionDefinitionWithBlock,\n            collectParameterValues = _require2.collectParameterValues;\n\n        var _require3 = require('../util/methodDataUtil'),\n            isAliasOfMethod = _require3.isAliasOfMethod;\n\n        var get = require('lodash/get');\n        var includes = require('lodash/includes');\n\n        function onlyHasPush(func) {\n            var firstLine = getFirstFunctionLine(func);\n            var firstParam = get(func, 'params[0]');\n            var exp = func && !isFunctionDefinitionWithBlock(func) ? firstLine : firstLine && firstLine.expression;\n            return func && hasOnlyOneStatement(func) && getMethodName(exp) === 'push' && !includes(collectParameterValues(firstParam), get(exp, 'callee.object.name'));\n        }\n\n        return getLodashMethodVisitors(context, function (node, iteratee, _ref) {\n            var method = _ref.method,\n                version = _ref.version;\n\n            if (isAliasOfMethod(version, 'forEach', method) && onlyHasPush(iteratee)) {\n                context.report(node, 'Prefer _.map over a _.forEach with a push to an array inside');\n            }\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-matches.js":"/**\n * @fileoverview Rule to check if an \"&&\" experssion should be a call to _.get or _.has\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if an \"&&\" experssion should be a call to _.get or _.has\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'integer',\n            minimum: 2\n        }]\n    },\n\n    create: function create(context) {\n        var DEFAULT_LENGTH = 3;\n\n        var _require = require('../util/astUtil'),\n            isComputed = _require.isComputed,\n            isEquivalentMemberExp = _require.isEquivalentMemberExp,\n            isEqEqEq = _require.isEqEqEq;\n\n        var ruleDepth = parseInt(context.options[0], 10) || DEFAULT_LENGTH;\n        var get = require('lodash/get');\n\n        var expStates = [];\n        function getState() {\n            return expStates[expStates.length - 1] || { depth: 0 };\n        }\n\n        function isMemberExpOfNodeOrRightmost(node, toCompare) {\n            return node.type === 'MemberExpression' && !isComputed(node) && (!toCompare || isEquivalentMemberExp(node.object, toCompare));\n        }\n\n        function shouldCheckDeeper(node, toCompare) {\n            return node.operator === '&&' && isEqEqEq(node.right) && isMemberExpOfNodeOrRightmost(node.right.left, toCompare);\n        }\n\n        return {\n            LogicalExpression: function LogicalExpression(node) {\n                var state = getState();\n                if (shouldCheckDeeper(node, state.node)) {\n                    expStates.push({ depth: state.depth + 1, node: node.right.left.object });\n                    if (isEquivalentMemberExp(get(node, 'left.left.object'), get(node, 'right.left.object')) && state.depth >= ruleDepth - 2) {\n                        context.report(node, 'Prefer _.isMatch over conditions on the same object');\n                    }\n                }\n            },\n            'LogicalExpression:exit': function LogicalExpressionExit(node) {\n                var state = getState();\n                if (state && state.node === get(node, 'right.left.object')) {\n                    expStates.pop();\n                }\n            }\n        };\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-noop.js":"/**\n * @fileoverview Rule to prefer _.noop over an empty function\n */\n'use strict';\n\n/**\n * @fileoverview Rule to prefer _.noop over an empty function\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/astUtil'),\n            getFirstFunctionLine = _require.getFirstFunctionLine;\n\n        function reportIfEmptyFunction(node) {\n            if (!getFirstFunctionLine(node) && node.parent.type !== 'MethodDefinition' && !node.generator && !node.async) {\n                context.report(node, 'Prefer _.noop over an empty function');\n            }\n        }\n\n        return {\n            FunctionExpression: reportIfEmptyFunction,\n            ArrowFunctionExpression: reportIfEmptyFunction\n        };\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-over-quantifier.js":"/**\n * @fileoverview Rule to check if a _.filter condition or multiple filters should be _.overEvery or _.overSome\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if a _.filter condition or multiple filters should be _.overEvery or _.overSome\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashMethodVisitors = _require.getLodashMethodVisitors;\n\n        var _require2 = require('../util/astUtil'),\n            getValueReturnedInFirstStatement = _require2.getValueReturnedInFirstStatement,\n            getFirstParamName = _require2.getFirstParamName,\n            isObjectOfMethodCall = _require2.isObjectOfMethodCall,\n            getMethodName = _require2.getMethodName;\n\n        var _require3 = require('../util/methodDataUtil'),\n            isAliasOfMethod = _require3.isAliasOfMethod;\n\n        var conditionMethods = ['filter', 'reject', 'pickBy', 'omitBy', 'findIndex', 'findLastIndex', 'find', 'findLast', 'findKey', 'findLastKey'];\n        var message = 'Prefer _.{{method}} instead of a {{connective}}';\n\n        var reportConstants = {\n            '&&': {\n                method: 'overEvery',\n                connective: 'conjunction'\n            },\n            '||': {\n                method: 'overSome',\n                connective: 'disjunction'\n            }\n        };\n\n        function usesShorthandInChain(node) {\n            return node.arguments.length === 0 || node.arguments[0].type === 'Identifier';\n        }\n\n        function isOnlyParamInvocationsWithOperator(node, paramName, operator) {\n            if (node.type === 'CallExpression') {\n                return usesShorthandInChain(node) && node.arguments[0] && node.arguments[0].name === paramName;\n            }\n            if (node.type === 'LogicalExpression') {\n                return node.operator === operator && isOnlyParamInvocationsWithOperator(node.left, paramName, operator) && isOnlyParamInvocationsWithOperator(node.right, paramName, operator);\n            }\n        }\n\n        function isCallToConditionMethod(method, version) {\n            return conditionMethods.some(function (m) {\n                return isAliasOfMethod(version, m, method);\n            });\n        }\n\n        function reportIfConnectiveOfParamInvocations(node) {\n            var retVal = getValueReturnedInFirstStatement(node);\n            var paramName = getFirstParamName(node);\n            if (retVal && retVal.type === 'LogicalExpression' && (retVal.operator === '&&' || retVal.operator === '||')) {\n                if (isOnlyParamInvocationsWithOperator(retVal, paramName, retVal.operator)) {\n                    context.report(node, message, reportConstants[retVal.operator]);\n                }\n            }\n        }\n\n        function reportIfDoubleFilterLiteral(callType, node, version) {\n            if (callType === 'chained' && usesShorthandInChain(node) && isObjectOfMethodCall(node) && isCallToConditionMethod(getMethodName(node.parent.parent), version) && usesShorthandInChain(node.parent.parent)) {\n                context.report(node, message, reportConstants['&&']);\n            }\n        }\n\n        return getLodashMethodVisitors(context, function (node, iteratee, _ref) {\n            var method = _ref.method,\n                version = _ref.version,\n                callType = _ref.callType;\n\n            if (isCallToConditionMethod(method, version)) {\n                reportIfConnectiveOfParamInvocations(iteratee);\n                reportIfDoubleFilterLiteral(callType, node, version);\n            }\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-reject.js":"/**\n * @fileoverview Rule to check if a call to filter should be a call to reject\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if a call to filter should be a call to reject\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'integer'\n        }]\n    },\n\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            isCallToLodashMethod = _require.isCallToLodashMethod,\n            getLodashMethodVisitors = _require.getLodashMethodVisitors;\n\n        var _require2 = require('../util/astUtil'),\n            getValueReturnedInFirstStatement = _require2.getValueReturnedInFirstStatement,\n            getFirstParamName = _require2.getFirstParamName,\n            isNegationOfMemberOf = _require2.isNegationOfMemberOf,\n            isNotEqEqToMemberOf = _require2.isNotEqEqToMemberOf;\n\n        var _require3 = require('../util/methodDataUtil'),\n            isAliasOfMethod = _require3.isAliasOfMethod;\n\n        var DEFAULT_MAX_PROPERTY_PATH_LENGTH = 3;\n        var maxLength = parseInt(context.options[0], 10) || DEFAULT_MAX_PROPERTY_PATH_LENGTH;\n\n        function isNegativeExpressionFunction(func, lodashContext) {\n            var returnValue = getValueReturnedInFirstStatement(func);\n            var firstParamName = getFirstParamName(func);\n            return isNegationOfMemberOf(returnValue, firstParamName, { maxLength: maxLength }) || isNotEqEqToMemberOf(returnValue, firstParamName, { maxLength: maxLength }) || isCallToLodashMethod(func, 'negate', lodashContext);\n        }\n\n        return getLodashMethodVisitors(context, function (node, iteratee, _ref) {\n            var method = _ref.method,\n                version = _ref.version,\n                lodashContext = _ref.lodashContext;\n\n            if (isAliasOfMethod(version, 'filter', method) && isNegativeExpressionFunction(iteratee, lodashContext)) {\n                context.report(node, 'Prefer _.reject over negative condition');\n            }\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-some.js":"/**\n * @fileoverview Rule to check if a findIndex comparison should be a call to _.some\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if a findIndex comparison should be a call to _.some\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'object',\n            properties: {\n                includeNative: {\n                    type: 'boolean'\n                }\n            }\n        }]\n    },\n\n    create: function create(context) {\n        var includeNative = context.options[0] && context.options[0].includeNative;\n\n        var _require = require('../util/astUtil'),\n            getExpressionComparedToInt = _require.getExpressionComparedToInt,\n            isFindIndexCall = _require.isFindIndexCall;\n\n        var _require2 = require('../util/lodashUtil'),\n            getLodashMethodVisitors = _require2.getLodashMethodVisitors;\n\n        var _require3 = require('../util/methodDataUtil'),\n            isAliasOfMethod = _require3.isAliasOfMethod;\n\n        var visitors = getLodashMethodVisitors(context, function (node, iteratee, _ref) {\n            var method = _ref.method,\n                version = _ref.version;\n\n            if (isAliasOfMethod(version, 'findIndex', method) && node === getExpressionComparedToInt(node.parent, -1, true)) {\n                context.report(node, 'Prefer _.some over findIndex comparison to -1');\n            }\n        });\n\n        if (includeNative) {\n            visitors.BinaryExpression = function (node) {\n                if (isFindIndexCall(getExpressionComparedToInt(node, -1, true))) {\n                    context.report(node, 'Prefer _.some over findIndex comparison to -1');\n                }\n            };\n        }\n        return visitors;\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-startswith.js":"/**\n * @fileoverview Rule to check if a call to _.indexOf === 0 should be a call to _.startsWith\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if a call to _.indexOf === 0 should be a call to _.startsWith\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/astUtil'),\n            isIndexOfCall = _require.isIndexOfCall,\n            getExpressionComparedToInt = _require.getExpressionComparedToInt;\n\n        return {\n            BinaryExpression: function BinaryExpression(node) {\n                if (isIndexOfCall(getExpressionComparedToInt(node, 0))) {\n                    context.report(node, 'Prefer _.startsWith instead of comparing indexOf() to 0');\n                }\n            }\n        };\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-thru.js":"/**\n * @fileoverview Rule to check if there's a method in the chain start that can be in the chain\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if there's a method in the chain start that can be in the chain\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashContext = _require.getLodashContext;\n\n        var lodashContext = getLodashContext(context);\n        function isSingleArgumentFunctionCall(node) {\n            return node && node.type === 'CallExpression' && node.arguments.length === 1 && node.arguments[0].type !== 'Literal';\n        }\n\n        var visitors = lodashContext.getImportVisitors();\n        visitors.CallExpression = function (node) {\n            if (lodashContext.isLodashChainStart(node) && isSingleArgumentFunctionCall(node.arguments[0])) {\n                context.report(node, 'Prefer using thru instead of function call in chain start.');\n            }\n        };\n        return visitors;\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-times.js":"/**\n * @fileoverview Rule to check if a call to map should be a call to times\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if a call to map should be a call to times\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashMethodVisitors = _require.getLodashMethodVisitors;\n\n        var _require2 = require('../util/methodDataUtil'),\n            isAliasOfMethod = _require2.isAliasOfMethod;\n\n        var get = require('lodash/get');\n        return getLodashMethodVisitors(context, function (node, iteratee, _ref) {\n            var method = _ref.method,\n                version = _ref.version;\n\n            if (isAliasOfMethod(version, 'map', method) && get(iteratee, 'params.length') === 0) {\n                context.report(node, 'Prefer _.times over _.map without using arguments');\n            }\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prefer-wrapper-method.js":"/**\n * @fileoverview Rule to check if there's a method in the chain start that can be in the chain\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if there's a method in the chain start that can be in the chain\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            isLodashWrapperMethod = _require.isLodashWrapperMethod,\n            getLodashContext = _require.getLodashContext;\n\n        var lodashContext = getLodashContext(context);\n        var visitors = lodashContext.getImportVisitors();\n        visitors.CallExpression = function (node) {\n            if (lodashContext.isLodashChainStart(node) && isLodashWrapperMethod(node.arguments[0], lodashContext.version)) {\n                context.report(node, 'Prefer {{name}} with wrapper method over inside the chain start.', { name: node.arguments[0].callee.property.name });\n            }\n        };\n        return visitors;\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/preferred-alias.js":"/**\n * @fileoverview Rule to ensure consistency of aliases of lodash methods\n */\n'use strict';\n\n/**\n * @fileoverview Rule to ensure consistency of aliases of lodash methods\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {},\n\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashMethodVisitors = _require.getLodashMethodVisitors;\n\n        var _require2 = require('../util/methodDataUtil'),\n            isMainAlias = _require2.isMainAlias,\n            getMainAlias = _require2.getMainAlias;\n\n        var has = require('lodash/has');\n\n        return getLodashMethodVisitors(context, function (node, iteratee, _ref) {\n            var method = _ref.method,\n                version = _ref.version;\n\n            if (!isMainAlias(version, method)) {\n                var mainAlias = getMainAlias(version, method);\n                if (mainAlias) {\n                    context.report({\n                        node: node,\n                        message: 'Method \\'' + method + '\\' is an alias, for consistency prefer using \\'' + mainAlias + '\\''\n                    });\n                }\n            }\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/prop-shorthand.js":"/**\n * @fileoverview Rule to check if the property shorthand can be used\n */\n'use strict';\n\n/**\n * @fileoverview Rule to check if the property shorthand can be used\n */\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            enum: ['always', 'never']\n        }]\n    },\n\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            isCallToLodashMethod = _require.isCallToLodashMethod,\n            getShorthandVisitors = _require.getShorthandVisitors;\n\n        var _require2 = require('../util/astUtil'),\n            isMemberExpOf = _require2.isMemberExpOf,\n            getValueReturnedInFirstStatement = _require2.getValueReturnedInFirstStatement,\n            getFirstParamName = _require2.getFirstParamName;\n\n        function isExplicitParamFunction(func) {\n            return isMemberExpOf(getValueReturnedInFirstStatement(func), getFirstParamName(func), { allowComputed: false });\n        }\n\n        function canUseShorthand(iteratee, lodashContext) {\n            return isCallToLodashMethod(iteratee, 'property', lodashContext) || isExplicitParamFunction(iteratee);\n        }\n\n        function usesShorthand(node, iteratee) {\n            return iteratee && iteratee.type === 'Literal' && !node.arguments[node.arguments.indexOf(iteratee) + 1];\n        }\n\n        return getShorthandVisitors(context, {\n            canUseShorthand: canUseShorthand,\n            usesShorthand: usesShorthand\n        }, {\n            always: 'Prefer property shorthand syntax',\n            never: 'Do not use property shorthand syntax'\n        });\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/rules/unwrap.js":"/**\n * @fileoverview Rule to ensure a lodash chain ends\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n    create: function create(context) {\n        var _require = require('../util/lodashUtil'),\n            getLodashContext = _require.getLodashContext,\n            isChainable = _require.isChainable,\n            isCallToMethod = _require.isCallToMethod,\n            isChainBreaker = _require.isChainBreaker;\n\n        var _require2 = require('../util/astUtil'),\n            getCaller = _require2.getCaller;\n\n        var negate = require('lodash/negate');\n        var lodashContext = getLodashContext(context);\n        var version = lodashContext.version;\n        function isCommit(node) {\n            return isCallToMethod(node, version, 'commit');\n        }\n\n        function getEndOfChain(node, isExplicit) {\n            var stillInChain = isExplicit ? negate(isChainBreaker) : isChainable;\n            var curr = node.parent.parent;\n            while (curr === getCaller(curr.parent.parent) && stillInChain(curr, version)) {\n                curr = curr.parent.parent;\n            }\n            return curr;\n        }\n\n        var visitors = lodashContext.getImportVisitors();\n        visitors.CallExpression = function (node) {\n            if (lodashContext.isImplicitChainStart(node)) {\n                var end = getEndOfChain(node, false);\n                if (!isCommit(end) && isChainable(end, version)) {\n                    context.report(end, 'Missing unwrapping at end of chain');\n                }\n            } else if (lodashContext.isExplicitChainStart(node)) {\n                var _end = getEndOfChain(node, true);\n                if (!isCommit(_end) && !isChainBreaker(_end, version)) {\n                    context.report(_end, 'Missing unwrapping at end of chain');\n                }\n            }\n        };\n        return visitors;\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/util/astUtil.js":"'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _ = require('lodash');\n\n/**\n * Gets the object that called the method in a CallExpression\n * @param {Object} node\n * @returns {Object|undefined}\n */\nvar getCaller = _.property(['callee', 'object']);\n\n/**\n * Gets the name of a method in a CallExpression\n * @param {Object} node\n * @returns {string|undefined}\n */\nvar getMethodName = _.property(['callee', 'property', 'name']);\n\n/**\n * Returns whether the node is a method call\n * @param {Object} node\n * @returns {boolean}\n */\nvar isMethodCall = _.matches({ type: 'CallExpression', callee: { type: 'MemberExpression' } });\n\nvar isFunctionExpression = _.overSome(_.matchesProperty('type', 'FunctionExpression'), _.matchesProperty('type', 'FunctionDeclaration'));\n/**\n * Returns whether the node is a function declaration that has a block\n * @param {Object} node\n * @returns {boolean}\n */\nvar isFunctionDefinitionWithBlock = _.overSome(isFunctionExpression, _.matches({ type: 'ArrowFunctionExpression', body: { type: 'BlockStatement' } }));\n\n/**\n * If the node specified is a function, returns the node corresponding with the first statement/expression in that function\n * @param {Object} node\n * @returns {node|undefined}\n */\nvar getFirstFunctionLine = _.cond([[isFunctionDefinitionWithBlock, _.property(['body', 'body', 0])], [_.matches({ type: 'ArrowFunctionExpression' }), _.property('body')]]);\n\n/**\n *\n * @param {Object} node\n * @returns {boolean|undefined}\n */\nvar isPropAccess = _.overSome(_.matches({ computed: false }), _.matchesProperty(['property', 'type'], 'Literal'));\n\n/**\n * Returns whether the node is a member expression starting with the same object, up to the specified length\n * @param {Object} node\n * @param {string} objectName\n * @param {Object} [options]\n * @param {number} [options.maxLength]\n * @param {boolean} [options.allowComputed]\n * @returns {boolean|undefined}\n */\nfunction isMemberExpOf(node, objectName) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref$maxLength = _ref.maxLength,\n        maxLength = _ref$maxLength === undefined ? Number.MAX_VALUE : _ref$maxLength,\n        allowComputed = _ref.allowComputed;\n\n    if (objectName) {\n        var curr = node;\n        var depth = maxLength;\n        while (curr && depth) {\n            if (allowComputed || isPropAccess(curr)) {\n                if (curr.type === 'MemberExpression' && curr.object.name === objectName) {\n                    return true;\n                }\n                curr = curr.object;\n                depth--;\n            } else {\n                return false;\n            }\n        }\n    }\n}\n\n/**\n * Returns the name of the first parameter of a function, if it exists\n * @param {Object} func\n * @returns {string|undefined}\n */\nvar getFirstParamName = _.property(['params', 0, 'name']);\n\n/**\n * Returns whether or not the expression is a return statement\n * @param {Object} exp\n * @returns {boolean|undefined}\n */\nvar isReturnStatement = _.matchesProperty('type', 'ReturnStatement');\n\n/**\n * Returns whether the node specified has only one statement\n * @param {Object} func\n * @returns {boolean}\n */\nfunction hasOnlyOneStatement(func) {\n    if (isFunctionDefinitionWithBlock(func)) {\n        return _.get(func, 'body.body.length') === 1;\n    }\n    if (func.type === 'ArrowFunctionExpression') {\n        return !_.get(func, 'body.body');\n    }\n}\n\n/**\n * Returns whether the node is an object of a method call\n * @param {Object} node\n * @returns {boolean}\n */\nfunction isObjectOfMethodCall(node) {\n    return _.get(node, 'parent.object') === node && _.get(node, 'parent.parent.type') === 'CallExpression';\n}\n\n/**\n * Returns whether the node is a literal\n * @param {Object} node\n * @returns {boolean}\n */\nfunction isLiteral(node) {\n    return node.type === 'Literal';\n}\n\n/**\n * Returns whether the expression specified is a binary expression with the specified operator and one of its sides is a member expression of the specified object name\n * @param {string} operator\n * @param {Object} exp\n * @param {string} objectName\n * @param {number} maxLength\n * @param {boolean} allowComputed\n * @param {boolean} onlyLiterals\n * @returns {boolean|undefined}\n */\nfunction isBinaryExpWithMemberOf(operator, exp, objectName) {\n    var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n        maxLength = _ref2.maxLength,\n        allowComputed = _ref2.allowComputed,\n        onlyLiterals = _ref2.onlyLiterals;\n\n    if (!_.isMatch(exp, { type: 'BinaryExpression', operator: operator })) {\n        return false;\n    }\n\n    var _map = [exp.left, exp.right].map(function (side) {\n        return isMemberExpOf(side, objectName, { maxLength: maxLength, allowComputed: allowComputed });\n    }),\n        _map2 = _slicedToArray(_map, 2),\n        left = _map2[0],\n        right = _map2[1];\n\n    return left === !right && (!onlyLiterals || isLiteral(exp.left) || isLiteral(exp.right));\n}\n\n/**\n * Returns whether the specified expression is a negation.\n * @param {Object} exp\n * @returns {boolean|undefined}\n */\nvar isNegationExpression = _.matches({ type: 'UnaryExpression', operator: '!' });\n\n/**\n * Returns whether the expression is a negation of a member of objectName, in the specified depth.\n * @param {Object} exp\n * @param {string} objectName\n * @param {number} maxLength\n * @returns {boolean|undefined}\n */\nfunction isNegationOfMemberOf(exp, objectName) {\n    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        maxLength = _ref3.maxLength;\n\n    return isNegationExpression(exp) && isMemberExpOf(exp.argument, objectName, { maxLength: maxLength, allowComputed: false });\n}\n\n/**\n *\n * @param {Object} exp\n * @param {string} paramName\n * @returns {boolean|undefined}\n */\nfunction isIdentifierWithName(exp, paramName) {\n    return exp && paramName && exp.type === 'Identifier' && exp.name === paramName;\n}\n\n/**\n * Returns the node of the value returned in the first line, if any\n * @param {Object} func\n * @returns {Object|undefined}\n */\nfunction getValueReturnedInFirstStatement(func) {\n    var firstLine = getFirstFunctionLine(func);\n    if (func) {\n        if (isFunctionDefinitionWithBlock(func)) {\n            return isReturnStatement(firstLine) ? firstLine.argument : undefined;\n        }\n        if (func.type === 'ArrowFunctionExpression') {\n            return firstLine;\n        }\n    }\n}\n\n/**\n * Returns whether the node is a call from the specified object name\n * @param {Object} node\n * @param {string} objName\n * @returns {boolean|undefined}\n */\nfunction isCallFromObject(node, objName) {\n    return node && objName && node.type === 'CallExpression' && _.get(node, 'callee.object.name') === objName;\n}\n\n/**\n * Returns whether the node is actually computed (x['ab'] does not count, x['a' + 'b'] does\n * @param {Object} node\n * @returns {boolean|undefined}\n */\nfunction isComputed(node) {\n    return _.get(node, 'computed') && node.property.type !== 'Literal';\n}\n\n/**\n * Returns whether the two expressions refer to the same object (e.g. a['b'].c and a.b.c)\n * @param {Object} a\n * @param {Object} b\n * @returns {boolean}\n */\nfunction isEquivalentMemberExp(a, b) {\n    return _.isEqualWith(a, b, function (left, right, key) {\n        if (_.includes(['loc', 'range', 'computed', 'start', 'end', 'parent'], key)) {\n            return true;\n        }\n        if (isComputed(left) || isComputed(right)) {\n            return false;\n        }\n        if (key === 'property') {\n            var leftValue = left.name || left.value;\n            var rightValue = right.name || right.value;\n            return leftValue === rightValue;\n        }\n    });\n}\n\n/**\n * Returns whether the expression is a strict equality comparison, ===\n * @param {Object} node\n * @returns {boolean}\n */\nvar isEqEqEq = _.matches({ type: 'BinaryExpression', operator: '===' });\n\nvar isMinus = function isMinus(node) {\n    return node.type === 'UnaryExpression' && node.operator === '-';\n};\n\n/**\n * Enum for type of comparison to int literal\n * @readonly\n * @enum {number}\n */\nvar comparisonType = {\n    exact: 0,\n    over: 1,\n    under: 2,\n    any: 3\n};\nvar comparisonOperators = ['==', '!=', '===', '!=='];\n\nfunction getIsValue(value) {\n    return value < 0 ? _.overEvery(isMinus, _.matches({ argument: { value: -value } })) : _.matches({ value: value });\n}\n\n/**\n * Returns the expression compared to the value in a binary expression, or undefined if there isn't one\n * @param {Object} node\n * @param {number} value\n * @param {boolean} [checkOver=false]\n * @returns {Object|undefined}\n */\nfunction getExpressionComparedToInt(node, value, checkOver) {\n    var isValue = getIsValue(value);\n    if (_.includes(comparisonOperators, node.operator)) {\n        if (isValue(node.right)) {\n            return node.left;\n        }\n        if (isValue(node.left)) {\n            return node.right;\n        }\n    }\n    if (checkOver) {\n        if (node.operator === '>' && isValue(node.right)) {\n            return node.left;\n        }\n        if (node.operator === '<' && isValue(node.left)) {\n            return node.right;\n        }\n        var isNext = getIsValue(value + 1);\n        if ((node.operator === '>=' || node.operator === '<') && isNext(node.right)) {\n            return node.left;\n        }\n        if ((node.operator === '<=' || node.operator === '>') && isNext(node.left)) {\n            return node.right;\n        }\n    }\n}\n\n/**\n * Returns whether the node is a call to indexOf\n * @param {Object} node\n * @returns {boolean}\n */\nvar isIndexOfCall = function isIndexOfCall(node) {\n    return isMethodCall(node) && getMethodName(node) === 'indexOf';\n};\n\n/**\n * Returns whether the node is a call to findIndex\n * @param {Object} node\n * @returns {boolean}\n */\nvar isFindIndexCall = function isFindIndexCall(node) {\n    return isMethodCall(node) && getMethodName(node) === 'findIndex';\n};\n\n/**\n * Returns an array of identifier names returned in a parameter or variable definition\n * @param node an AST node which is a parameter or variable declaration\n * @returns {string[]} List of names defined in the parameter\n */\nfunction collectParameterValues(node) {\n    switch (node && node.type) {\n        case 'Identifier':\n            return [node.name];\n        case 'ObjectPattern':\n            return _.flatMap(node.properties, function (prop) {\n                return collectParameterValues(prop.value);\n            });\n        case 'ArrayPattern':\n            return _.flatMap(node.elements, collectParameterValues);\n        default:\n            return [];\n    }\n}\n\nmodule.exports = {\n    getCaller: getCaller,\n    getMethodName: getMethodName,\n    isMethodCall: isMethodCall,\n    getFirstFunctionLine: getFirstFunctionLine,\n    isMemberExpOf: isMemberExpOf,\n    getFirstParamName: getFirstParamName,\n    hasOnlyOneStatement: hasOnlyOneStatement,\n    isObjectOfMethodCall: isObjectOfMethodCall,\n    isEqEqEqToMemberOf: isBinaryExpWithMemberOf.bind(null, '==='),\n    isNotEqEqToMemberOf: isBinaryExpWithMemberOf.bind(null, '!=='),\n    isNegationOfMemberOf: isNegationOfMemberOf,\n    isIdentifierWithName: isIdentifierWithName,\n    isNegationExpression: isNegationExpression,\n    getValueReturnedInFirstStatement: getValueReturnedInFirstStatement,\n    isCallFromObject: isCallFromObject,\n    isComputed: isComputed,\n    isEquivalentMemberExp: isEquivalentMemberExp,\n    isEqEqEq: isEqEqEq,\n    comparisonType: comparisonType,\n    getExpressionComparedToInt: getExpressionComparedToInt,\n    isIndexOfCall: isIndexOfCall,\n    isFindIndexCall: isFindIndexCall,\n    isFunctionExpression: isFunctionExpression,\n    isFunctionDefinitionWithBlock: isFunctionDefinitionWithBlock,\n    collectParameterValues: collectParameterValues\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/util/LodashContext.js":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _require = require('./settingsUtil'),\n    getSettings = _require.getSettings;\n\nvar _require2 = require('./astUtil'),\n    isMethodCall = _require2.isMethodCall,\n    isCallFromObject = _require2.isCallFromObject,\n    getCaller = _require2.getCaller,\n    getMethodName = _require2.getMethodName;\n\nvar _require3 = require('./importUtil'),\n    getNameFromCjsRequire = _require3.getNameFromCjsRequire,\n    isFullLodashImport = _require3.isFullLodashImport,\n    getMethodImportFromName = _require3.getMethodImportFromName;\n\n/* Class representing lodash data for a given context */\n\n\nmodule.exports = function () {\n    /**\n     * Create a Lodash context wrapper from a file's RuleContext\n     * @param {RuleContext} context\n     */\n    function _class(context) {\n        _classCallCheck(this, _class);\n\n        this.context = context;\n        this.general = Object.create(null);\n        this.methods = Object.create(null);\n    }\n\n    /**\n     * Gets visitors to collect lodash declarations in the context\n     * @returns {Object} visitors for every where Lodash can be declared\n     */\n\n\n    _createClass(_class, [{\n        key: 'getImportVisitors',\n        value: function getImportVisitors() {\n            var self = this;\n            return {\n                ImportDeclaration: function ImportDeclaration(_ref) {\n                    var source = _ref.source,\n                        specifiers = _ref.specifiers;\n\n                    if (isFullLodashImport(source.value)) {\n                        specifiers.forEach(function (spec) {\n                            switch (spec.type) {\n                                case 'ImportNamespaceSpecifier':\n                                case 'ImportDefaultSpecifier':\n                                    self.general[spec.local.name] = true;\n                                    break;\n                                case 'ImportSpecifier':\n                                    self.methods[spec.local.name] = spec.imported.name;\n                                    break;\n                            }\n                        });\n                    } else {\n                        var method = getMethodImportFromName(source.value);\n                        if (method) {\n                            self.methods[specifiers[0].local.name] = method;\n                        }\n                    }\n                },\n                VariableDeclarator: function VariableDeclarator(_ref2) {\n                    var init = _ref2.init,\n                        id = _ref2.id;\n\n                    var required = getNameFromCjsRequire(init);\n                    if (isFullLodashImport(required)) {\n                        if (id.type === 'Identifier') {\n                            self.general[id.name] = true;\n                        } else if (id.type === 'ObjectPattern') {\n                            id.properties.forEach(function (prop) {\n                                self.methods[prop.value.name] = prop.key.name;\n                            });\n                        }\n                    } else if (required) {\n                        var method = getMethodImportFromName(required);\n                        if (method) {\n                            self.methods[id.name] = method;\n                        }\n                    }\n                }\n            };\n        }\n\n        /**\n         * Returns whether the node is an imported Lodash in this context\n         * @param node\n         * @returns {boolean|undefined}\n         */\n\n    }, {\n        key: 'isImportedLodash',\n        value: function isImportedLodash(node) {\n            if (node && node.type === 'Identifier') {\n                return this.general[node.name];\n            }\n        }\n\n        /**\n         * Returns the name of the Lodash method for this node, if any\n         * @param node\n         * @returns {string|undefined}\n         */\n\n    }, {\n        key: 'getImportedLodashMethod',\n        value: function getImportedLodashMethod(node) {\n            if (node && node.type === 'CallExpression' && !isMethodCall(node)) {\n                return this.methods[node.callee.name];\n            }\n        }\n\n        /**\n         * Returns whether the node is a call from a Lodash object\n         * @param node\n         * @returns {boolean|undefined}\n         */\n\n    }, {\n        key: 'isLodashCall',\n        value: function isLodashCall(node) {\n            return this.pragma && isCallFromObject(node, this.pragma) || this.isImportedLodash(getCaller(node));\n        }\n\n        /**\n         * Returns whether the node is an implicit chain start, _()...\n         * @param node\n         * @returns {boolean|undefined}\n         */\n\n    }, {\n        key: 'isImplicitChainStart',\n        value: function isImplicitChainStart(node) {\n            return this.pragma && node.callee.name === this.pragma || this.isImportedLodash(node.callee);\n        }\n\n        /**\n         * Returns whether the node is an explicit chain start, _.chain()...\n         * @param node\n         * @returns {boolean|undefined}\n         */\n\n    }, {\n        key: 'isExplicitChainStart',\n        value: function isExplicitChainStart(node) {\n            return this.isLodashCall(node) && getMethodName(node) === 'chain';\n        }\n\n        /**\n         * Returns whether the node is a Lodash chain start, implicit or explicit\n         * @param node\n         * @returns {*|boolean|boolean|undefined}\n         */\n\n    }, {\n        key: 'isLodashChainStart',\n        value: function isLodashChainStart(node) {\n            return node && node.type === 'CallExpression' && (this.isImplicitChainStart(node) || this.isExplicitChainStart(node));\n        }\n\n        /**\n         *\n         * @returns {number} the current Lodash version\n         */\n\n    }, {\n        key: 'version',\n        get: function get() {\n            if (!this._version) {\n                var _getSettings = getSettings(this.context),\n                    pragma = _getSettings.pragma,\n                    version = _getSettings.version;\n\n                this._pragma = pragma;\n                this._version = version;\n            }\n            return this._version;\n        }\n\n        /**\n         *\n         * @returns {string|undefined} the current Lodash pragma\n         */\n\n    }, {\n        key: 'pragma',\n        get: function get() {\n            if (!this._pragma) {\n                var _getSettings2 = getSettings(this.context),\n                    pragma = _getSettings2.pragma,\n                    version = _getSettings2.version;\n\n                this._pragma = pragma;\n                this._version = version;\n            }\n            return this._pragma;\n        }\n    }]);\n\n    return _class;\n}();","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/util/settingsUtil.js":"'use strict';\n\nvar _ = require('lodash');\nmodule.exports = {\n    /**\n     * Returns the lodash object settings, with default values if missing\n     * @param context\n     * @returns {LodashSettings}\n     */\n    getSettings: function getSettings(context) {\n        return _.chain(context).get(['settings', 'lodash']).clone().defaults({\n            version: 4\n        }).value();\n    },\n\n\n    /**\n     * Gets whether the ecmaFeature specified is on for the context\n     * @param context\n     * @param {string} featureName\n     */\n    isEcmaFeatureOn: function isEcmaFeatureOn(context, featureName) {\n        return _.get(context, ['ecmaFeatures', featureName]) || _.get(context, ['parserOptions', 'ecmaVersion'], 0) > 5;\n    }\n};\n\n/**\n @typedef {Object} LodashSettings\n @property {String} pragma - The symbol that signifies Lodash (default is '_').\n @property {Number} version - The major version number (default is 4).\n*/","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/util/lodashUtil.js":"'use strict';\n\nvar _ = require('lodash');\nvar methodDataUtil = require('./methodDataUtil');\nvar astUtil = require('./astUtil');\nvar settingsUtil = require('./settingsUtil');\nvar LodashContext = require('./LodashContext');\n\n/**\n * Returns whether or not a node is a chainable method call in the specified version\n * @param {Object} node\n * @param {number} version\n * @returns {boolean}\n */\nfunction isChainable(node, version) {\n    return methodDataUtil.isChainable(version, astUtil.getMethodName(node));\n}\n\n/**\n * Returns whehter the node is a chain breaker method in the specified version\n * @param {Object} node\n * @param {number} version\n * @returns {boolean}\n */\nfunction isChainBreaker(node, version) {\n    return methodDataUtil.isAliasOfMethod(version, 'value', astUtil.getMethodName(node));\n}\n\n/**\n * Returns whether the node is a call to the specified method or one of its aliases in the version\n * @param {Object} node\n * @param {number} version\n * @param {string} method\n * @returns {boolean}\n */\nfunction isCallToMethod(node, version, method) {\n    return methodDataUtil.isAliasOfMethod(version, method, astUtil.getMethodName(node));\n}\n\n/**\n * Returns whether or not the node is a call to a lodash wrapper method\n * @param {Object} node\n * @param {number} version\n * @returns {boolean}\n */\nfunction isLodashWrapperMethod(node, version) {\n    return methodDataUtil.isWrapperMethod(version, astUtil.getMethodName(node));\n}\n\n/**\n * Gets the 'isX' method for a specified type, e.g. isObject\n * @param {string} name\n * @returns {string|null}\n */\nfunction getIsTypeMethod(name) {\n    var types = ['number', 'boolean', 'function', 'Function', 'string', 'object', 'undefined', 'Date', 'Array', 'Error', 'Element'];\n    return _.includes(types, name) ? 'is' + _.capitalize(name) : null;\n}\n\n/**\n * Returns whether or not the node is a call to a native collection method\n * @param {Object} node\n * @returns {boolean}\n */\nfunction isNativeCollectionMethodCall(node) {\n    return _.includes(['every', 'fill', 'filter', 'find', 'findIndex', 'forEach', 'includes', 'map', 'reduce', 'reduceRight', 'some'], astUtil.getMethodName(node));\n}\n\n/**\n * Gets the context's Lodash settings and a function and returns a visitor that calls the function for every Lodash or chain call\n * @param {LodashContext} lodashContext\n * @param {LodashReporter} reporter\n * @returns {NodeTypeVisitor}\n */\nfunction getLodashMethodCallExpVisitor(lodashContext, reporter) {\n    return function (node) {\n        var version = lodashContext.version;\n        var iterateeIndex = void 0;\n        if (lodashContext.isLodashChainStart(node)) {\n            var prevNode = node;\n            node = node.parent.parent;\n            while (astUtil.getCaller(node) === prevNode && astUtil.isMethodCall(node) && !isChainBreaker(node, version)) {\n                var method = astUtil.getMethodName(node);\n                iterateeIndex = methodDataUtil.getIterateeIndex(version, method);\n                reporter(node, node.arguments[iterateeIndex - 1], { callType: 'chained', method: method, version: version, lodashContext: lodashContext });\n                prevNode = node;\n                node = node.parent.parent;\n            }\n        } else if (lodashContext.isLodashCall(node)) {\n            var _method = astUtil.getMethodName(node);\n            iterateeIndex = methodDataUtil.getIterateeIndex(version, _method);\n            reporter(node, node.arguments[iterateeIndex], { callType: 'method', method: _method, version: version, lodashContext: lodashContext });\n        } else if (version !== 3) {\n            var _method2 = lodashContext.getImportedLodashMethod(node);\n            if (_method2) {\n                iterateeIndex = methodDataUtil.getIterateeIndex(version, _method2);\n                reporter(node, node.arguments[iterateeIndex], { method: _method2, callType: 'single', version: version, lodashContext: lodashContext });\n            }\n        }\n    };\n}\n\nfunction isLodashCallToMethod(node, method, lodashContext) {\n    return lodashContext.isLodashCall(node) && isCallToMethod(node, lodashContext.version, method);\n}\n\nfunction isCallToLodashMethod(node, method, lodashContext) {\n    if (!node || node.type !== 'CallExpression') {\n        return false;\n    }\n    return isLodashCallToMethod(node, method, lodashContext) || methodDataUtil.isAliasOfMethod(lodashContext.version, method, lodashContext.getImportedLodashMethod(node));\n}\n\nfunction getLodashMethodVisitors(context, lodashCallExpVisitor) {\n    var lodashContext = new LodashContext(context);\n    var visitors = lodashContext.getImportVisitors();\n    visitors.CallExpression = getLodashMethodCallExpVisitor(lodashContext, lodashCallExpVisitor);\n    return visitors;\n}\n\nfunction getShorthandVisitors(context, checks, messages) {\n    var lodashContext = new LodashContext(context);\n    var visitors = lodashContext.getImportVisitors();\n    visitors.CallExpression = getLodashMethodCallExpVisitor(lodashContext, {\n        always: function always(node, iteratee, _ref) {\n            var method = _ref.method,\n                version = _ref.version;\n\n            if (methodDataUtil.methodSupportsShorthand(version, method) && checks.canUseShorthand(iteratee, lodashContext)) {\n                context.report(iteratee, messages.always);\n            }\n        },\n        never: function never(node, iteratee, _ref2) {\n            var method = _ref2.method;\n\n            if (checks.usesShorthand(node, iteratee, method)) {\n                context.report(iteratee || node.callee.property, messages.never);\n            }\n        }\n    }[context.options[0] || 'always']);\n    return visitors;\n}\n\n/**\n *\n * @param context\n * @returns {LodashContext} a LodashContext for a given context\n */\nfunction getLodashContext(context) {\n    return new LodashContext(context);\n}\n\nmodule.exports = {\n    isChainable: isChainable,\n    isChainBreaker: isChainBreaker,\n    isCallToMethod: isCallToMethod,\n    isLodashWrapperMethod: isLodashWrapperMethod,\n    getIsTypeMethod: getIsTypeMethod,\n    isNativeCollectionMethodCall: isNativeCollectionMethodCall,\n    getLodashMethodCallExpVisitor: getLodashMethodCallExpVisitor,\n    isCallToLodashMethod: isCallToLodashMethod,\n    getShorthandVisitors: getShorthandVisitors,\n    getLodashMethodVisitors: getLodashMethodVisitors,\n    getLodashContext: getLodashContext\n};\n\n/**\n @callback LodashReporter\n @param {Object} node\n @param {Object} iteratee\n @param {Object?} options\n */\n\n/**\n @callback NodeTypeVisitor\n @param {Object} node\n */\n\n/**\n * @typedef {Object} ShorthandChecks\n * @property {function} canUseShorthand\n * @property {function} usesShorthand\n */\n\n/**\n * @typedef {object} ShorthandMessages\n * @property {string} always\n * @property {string} never\n */","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/util/methodDataUtil.js":"'use strict';\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar _ = require('lodash');\n\nvar getMethodData = _.memoize(function (version) {\n    return require('./methodDataByVersion/' + version);\n});\n\n/**\n * Gets a major version number and method name and returns all its aliases including itself.\n * @param {Number} version\n * @param {string} method\n * @returns {string[]}\n */\nvar expandAlias = function expandAlias(version, method) {\n    var methodAliases = _.get(getMethodData(version), [method, 'aliases'], []);\n    return [method].concat(_toConsumableArray(methodAliases));\n};\n\n/**\n * Gets a major version number and a list of methods and returns a list of methods and all their aliases\n * @param version\n * @param methods\n * @returns {string[]}\n */\nfunction expandAliases(version, methods) {\n    return _.flatMap(methods, function (method) {\n        return expandAlias(version, method);\n    });\n}\n\n/**\n * Returns whether the method is the main alias\n * @param version\n * @param method\n * @returns {Boolean}\n */\nfunction isMainAlias(version, method) {\n    return Boolean(getMethodData(version)[method]);\n}\n\n/**\n * Gets a list of all chainable methods and their aliases for a given version\n * @param {Number} version\n * @param {string} method\n * @returns {boolean}\n */\nfunction isChainable(version, method) {\n    var data = getMethodData(version);\n    return _.get(data, [getMainAlias(version, method), 'chainable'], false);\n}\n\n/**\n * Gets whether the method is a collection method\n * @param {Number} version\n * @param {string} method\n * @returns {Boolean}\n */\nfunction isCollectionMethod(version, method) {\n    return methodSupportsShorthand(version, method) || _.includes(expandAliases(version, ['reduce', 'reduceRight']), method);\n}\n\n/**\n * Returns whether the node's method call supports using shorthands in the specified version\n * @param {Number} version\n * @param {string} method\n * @returns {boolean}\n */\nfunction methodSupportsShorthand(version, method) {\n    var mainAlias = getMainAlias(version, method);\n    return _.get(getMethodData(version), [mainAlias, 'shorthand']);\n}\n\n/**\n * Gets whether the method is a wrapper method\n * @param {Number} version\n * @param {string} method\n * @returns {boolean}\n */\nfunction isWrapperMethod(version, method) {\n    return _.get(getMethodData(version), [method, 'wrapper'], false);\n}\n/**\n * Gets whether the suspect is an alias of the method in a given version\n * @param {Number} version\n * @param {string} method\n * @param {string} suspect\n * @returns {boolean}\n */\nfunction isAliasOfMethod(version, method, suspect) {\n    return method === suspect || _.includes(_.get(getMethodData(version), [method, 'aliases']), suspect);\n}\n\n/**\n * Returns the main alias for the method in the specified version.\n * @param {number} version\n * @param {string} method\n * @returns {string}\n */\nfunction getMainAlias(version, method) {\n    var data = getMethodData(version);\n    return data[method] ? method : _.findKey(data, function (methodData) {\n        return _.includes(methodData.aliases, method);\n    });\n}\n\n/**\n * Gets the index of the iteratee of a method when it isn't chained, or -1 if it doesn't have one.\n * @param {number} version\n * @param {string} method\n * @returns {number}\n */\nfunction getIterateeIndex(version, method) {\n    var mainAlias = getMainAlias(version, method);\n    var methodData = getMethodData(version)[mainAlias];\n    if (_.has(methodData, 'iterateeIndex')) {\n        return methodData.iterateeIndex;\n    }\n    if (methodData && methodData.iteratee) {\n        return 1;\n    }\n    return -1;\n}\n\n/**\n * Gets the maximum number of arguments to be given to the function in the specified version\n * @param {number} version\n * @param {string} name\n * @returns {number}\n */\nfunction getFunctionMaxArity(version, name) {\n    return _.get(getMethodData(version), [name, 'args'], Infinity);\n}\n\nvar sideEffectIterationMethods = ['forEach', 'forEachRight', 'forIn', 'forInRight', 'forOwn', 'forOwnRight'];\n\n/**\n * Gets a list of side effect iteration methods by version\n * @param {number} version\n * @returns {string[]}\n */\nfunction getSideEffectIterationMethods(version) {\n    return expandAliases(version, sideEffectIterationMethods);\n}\n\nmodule.exports = {\n    isAliasOfMethod: isAliasOfMethod,\n    isChainable: isChainable,\n    methodSupportsShorthand: methodSupportsShorthand,\n    isWrapperMethod: isWrapperMethod,\n    isCollectionMethod: isCollectionMethod,\n    isMainAlias: isMainAlias,\n    getMainAlias: getMainAlias,\n    getIterateeIndex: getIterateeIndex,\n    getFunctionMaxArity: getFunctionMaxArity,\n    getSideEffectIterationMethods: getSideEffectIterationMethods\n};\n\n/**\n * A JSON object containing method info for a specific lodash major version\n @typedef {Object} VersionInfo\n @property {Aliases} aliases\n @property {[string]} wrapper\n @property {Object.<string, [string]>} wrapperAliases\n @property {[string]} property\n @property {[string]} chainable\n */","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/util/methodDataByVersion.js":"'use strict';\n\nmodule.exports = {\n    3: {\n        aliases: {\n            forEach: ['each'],\n            assign: ['extend'],\n            first: ['head'],\n            zipObject: ['object'],\n            rest: ['tail'],\n            uniq: ['unique'],\n            reduce: ['foldl', 'inject'],\n            reduceRight: ['foldr'],\n            some: ['any'],\n            map: ['collect'],\n            includes: ['contains', 'include'],\n            flowRight: ['backflow', 'compose'],\n            isEqual: ['eq'],\n            every: ['all'],\n            find: ['detect'],\n            forEachRight: ['eachRight'],\n            filter: ['select'],\n            functions: ['methods'],\n            callback: ['iteratee']\n        },\n        wrapper: ['concat', 'join', 'pop', 'push', 'reverse', 'shift', 'slice', 'sort', 'splice', 'unshift', 'replace', 'split'],\n        wrapperAliases: {\n            value: ['run', 'toJSON', 'valueOf']\n        },\n        shorthand: ['dropRightWhile', 'dropWhile', 'findIndex', 'findLastIndex', 'remove', 'sortedIndex', 'sortedLastIndex', 'map', 'takeRightWhile', 'takeWhile', 'uniq', 'countBy', 'every', 'filter', 'find', 'result', 'groupBy', 'indexBy', 'partition', 'reject', 'some', 'sortBy', 'sortByOrder', 'max', 'min', 'sum', 'findKey', 'findLastKey', 'mapValues'],\n        chainable: ['after', 'ary', 'assign', 'at', 'before', 'bind', 'bindAll', 'bindKey', 'callback', 'chain', 'chunk', 'commit', 'compact', 'concat', 'constant', 'countBy', 'create', 'curry', 'debounce', 'defaults', 'defaultsDeep', 'defer', 'delay', 'difference', 'drop', 'dropRight', 'dropRightWhile', 'dropWhile', 'fill', 'filter', 'flatten', 'flattenDeep', 'flow', 'flowRight', 'forEach', 'forEachRight', 'forIn', 'forInRight', 'forOwn', 'forOwnRight', 'functions', 'groupBy', 'indexBy', 'initial', 'intersection', 'invert', 'invoke', 'keys', 'keysIn', 'map', 'mapKeys', 'mapValues', 'matches', 'matchesProperty', 'memoize', 'merge', 'method', 'methodOf', 'mixin', 'modArgs', 'negate', 'omit', 'once', 'pairs', 'partial', 'partialRight', 'partition', 'pick', 'plant', 'pluck', 'property', 'propertyOf', 'pull', 'pullAt', 'push', 'range', 'rearg', 'reject', 'remove', 'rest', 'restParam', 'reverse', 'set', 'shuffle', 'slice', 'sort', 'sortBy', 'sortByAll', 'sortByOrder', 'splice', 'spread', 'take', 'takeRight', 'takeRightWhile', 'takeWhile', 'tap', 'throttle', 'thru', 'times', 'toArray', 'toPlainObject', 'transform', 'union', 'uniq', 'unshift', 'unzip', 'unzipWith', 'values', 'valuesIn', 'where', 'without', 'wrap', 'xor', 'zip', 'zipObject', 'zipWith'],\n        iteratee: {\n            any: ['dropRightWhile', 'dropWhile', 'findIndex', 'findLastIndex', 'remove', 'sortedIndex', 'sortedLastIndex', 'takeRightWhile', 'takeWhile', 'uniq', 'unzipWith', 'zipWith', 'tap', 'thru', 'countBy', 'every', 'filter', 'find', 'findLast', 'forEach', 'forEachRight', 'groupBy', 'indexBy', 'map', 'partition', 'reduce', 'reduceRight', 'reject', 'some', 'sortBy', 'max', 'min', 'sum', 'findKey', 'findLastKey', 'forIn', 'forInRight', 'forOwn', 'forOwnRight', 'mapKeys', 'mapValues', 'transform', 'times'],\n            differentIndex: {\n                sortedIndex: 2,\n                sortedLastIndex: 2\n            }\n        },\n        args: {\n            chunk: 2,\n            compact: 1,\n            drop: 2,\n            dropRight: 2,\n            dropRightWhile: 3,\n            dropWhile: 3,\n            fill: 4,\n            findIndex: 3,\n            findLastIndex: 3,\n            first: 1,\n            flatten: 2,\n            flattenDeep: 1,\n            fromIndex: 3,\n            initial: 1,\n            last: 1,\n            lastIndexOf: 3,\n            remove: 3,\n            rest: 1,\n            slice: 3,\n            sortedIndex: 4,\n            sortedLastIndex: 4,\n            take: 2,\n            takeRight: 2,\n            takeRightWhile: 3,\n            takeWhile: 3,\n            uniq: 4,\n            unzip: 1,\n            unzipWith: 3,\n            zipObject: 2,\n            tap: 3,\n            thru: 3,\n            countBy: 3,\n            every: 3,\n            filter: 3,\n            find: 3,\n            findLast: 3,\n            findWhere: 2,\n            forEach: 3,\n            forEachRight: 3,\n            groupBy: 3,\n            includes: 3,\n            indexBy: 3,\n            map: 3,\n            partition: 3,\n            pluck: 2,\n            reduce: 4,\n            reduceRight: 4,\n            reject: 3,\n            sample: 2,\n            shuffle: 1,\n            size: 1,\n            some: 3,\n            sortBy: 3,\n            where: 2,\n            after: 2,\n            ary: 2,\n            before: 2,\n            curry: 2,\n            curryRight: 2,\n            debounce: 3,\n            memoize: 2,\n            negate: 1,\n            once: 1,\n            restParam: 2,\n            spread: 1,\n            throttle: 3,\n            wrap: 2,\n            clone: 4,\n            cloneDeep: 3,\n            gt: 2,\n            gte: 2,\n            isArguments: 1,\n            isArray: 1,\n            isBoolean: 1,\n            isDate: 1,\n            isElement: 1,\n            isEmpty: 1,\n            isEqual: 4,\n            isError: 1,\n            isFinite: 1,\n            isFunction: 1,\n            isMatch: 4,\n            isNaN: 1,\n            isNative: 1,\n            isNull: 1,\n            isNumber: 1,\n            isObject: 1,\n            isPlainObject: 1,\n            isRegExp: 1,\n            isTypedArray: 1,\n            isUndefined: 1,\n            lt: 2,\n            lte: 2,\n            toArray: 1,\n            toPlainObject: 1,\n            add: 2,\n            ceil: 2,\n            floor: 2,\n            max: 3,\n            min: 3,\n            round: 2,\n            sum: 3,\n            inRange: 3,\n            random: 3,\n            create: 2,\n            findKey: 3,\n            findLastKey: 3,\n            forIn: 3,\n            forInRight: 3,\n            forOwn: 3,\n            forOwnRight: 3,\n            functions: 1,\n            get: 3,\n            has: 2,\n            invert: 2,\n            keys: 1,\n            keysIn: 1,\n            mapKeys: 3,\n            mapValues: 3,\n            pairs: 1,\n            result: 3,\n            set: 3,\n            transform: 4,\n            values: 1,\n            valuesIn: 1,\n            camelCase: 1,\n            capitalize: 1,\n            deburr: 1,\n            endsWith: 3,\n            escape: 1,\n            escapeRegExp: 1,\n            kebabCase: 1,\n            pad: 3,\n            padLeft: 3,\n            padRight: 3,\n            parseInt: 2,\n            repeat: 2,\n            snakeCase: 2,\n            startCase: 2,\n            startsWith: 3,\n            template: 2,\n            trim: 2,\n            trimLeft: 2,\n            trimRight: 2,\n            trunc: 3,\n            unescape: 1,\n            words: 2,\n            callback: 2,\n            constant: 1,\n            identity: 1,\n            matches: 1,\n            matchesProperty: 2,\n            mixin: 3,\n            noConflict: 0,\n            noop: 0,\n            property: 1,\n            propertyOf: 1,\n            range: 3,\n            runInContext: 1,\n            times: 3,\n            uniqueId: 1\n        }\n    },\n    4: {\n        aliases: {\n            assignIn: ['extend'],\n            assignInWith: ['extendWith'],\n            forEach: ['each'],\n            forEachRight: ['eachRight'],\n            head: ['first']\n        },\n        wrapper: ['concat', 'join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'],\n        wrapperAliases: {\n            value: ['toJSON', 'valueOf']\n        },\n        shorthand: ['differenceBy', 'dropRightWhile', 'dropWhile', 'every', 'filter', 'find', 'findIndex', 'findKey', 'findLastIndex', 'findLastKey', 'flatMapDeep', 'flatMapDepth', 'groupBy', 'intersectionBy', 'invertBy', 'map', 'mapValues', 'maxBy', 'minBy', 'overSome', 'overEvery', 'partition', 'reject', 'remove', 'some', 'sortedIndexBy', 'sortedLastIndexBy', 'sumBy', 'takeRightWhile', 'takeWhile', 'unionBy', 'uniqBy', 'xorBy'],\n        chainable: ['after', 'ary', 'assign', 'assignIn', 'assignInWith', 'assignWith', 'at', 'before', 'bind', 'bindAll', 'bindKey', 'castArray', 'chain', 'chunk', 'commit', 'compact', 'concat', 'conforms', 'constant', 'countBy', 'create', 'curry', 'debounce', 'defaults', 'defaultsDeep', 'defer', 'delay', 'difference', 'differenceBy', 'differenceWith', 'drop', 'dropRight', 'dropRightWhile', 'dropWhile', 'fill', 'filter', 'flatMap', 'flatMapDeep', 'flatMapDepth', 'flatten', 'flattenDeep', 'flattenDepth', 'flip', 'flow', 'flowRight', 'fromPairs', 'functions', 'functionsIn', 'groupBy', 'initial', 'intersection', 'intersectionBy', 'intersectionWith', 'invert', 'invertBy', 'invokeMap', 'iteratee', 'keyBy', 'keys', 'keysIn', 'map', 'mapKeys', 'mapValues', 'matches', 'matchesProperty', 'memoize', 'merge', 'mergeWith', 'method', 'methodOf', 'mixin', 'negate', 'nthArg', 'omit', 'omitBy', 'once', 'orderBy', 'over', 'overArgs', 'overEvery', 'overSome', 'partial', 'partialRight', 'partition', 'pick', 'pickBy', 'plant', 'property', 'propertyOf', 'pull', 'pullAll', 'pullAllBy', 'pullAllWith', 'pullAt', 'push', 'range', 'rangeRight', 'rearg', 'reject', 'remove', 'rest', 'reverse', 'sampleSize', 'set', 'setWith', 'shuffle', 'slice', 'sort', 'sortBy', 'splice', 'spread', 'tail', 'take', 'takeRight', 'takeRightWhile', 'takeWhile', 'tap', 'throttle', 'thru', 'toArray', 'toPairs', 'toPairsIn', 'toPath', 'toPlainObject', 'transform', 'unary', 'union', 'unionBy', 'unionWith', 'uniq', 'uniqBy', 'uniqWith', 'unset', 'unshift', 'unzip', 'unzipWith', 'update', 'updateWith', 'values', 'valuesIn', 'without', 'wrap', 'xor', 'xorBy', 'xorWith', 'zip', 'zipObject', 'zipObjectDeep', 'zipWith'],\n        iteratee: {\n            any: ['cloneDeepWith', 'cloneWith', 'countBy', 'dropRightWhile', 'dropWhile', 'every', 'filter', 'find', 'findIndex', 'findKey', 'findLast', 'findLastIndex', 'findLastKey', 'flatMap', 'flatMapDeep', 'flatMapDepth', 'forEach', 'forEachRight', 'forIn', 'forInRight', 'forOwn', 'forOwnRight', 'groupBy', 'indexBy', 'invertBy', 'keyBy', 'map', 'mapKeys', 'mapValues', 'maxBy', 'meanBy', 'minBy', 'omitBy', 'partition', 'pickBy', 'reduce', 'reduceRight', 'reject', 'remove', 'some', 'sortedUniqBy', 'sumBy', 'takeRightWhile', 'takeWhile', 'tap', 'thru', 'times', 'transform', 'uniqBy', 'unzipWith', 'xorBy'],\n            differentIndex: {\n                pullAllBy: 2,\n                sortedIndex: 2,\n                sortedIndexBy: 2,\n                sortedLastIndex: 2,\n                sortedLastIndexBy: 2\n            }\n        },\n        args: {\n            add: 2,\n            after: 2,\n            ary: 2,\n            before: 2,\n            camelCase: 1,\n            capitalize: 1,\n            castArray: 1,\n            ceil: 2,\n            chain: 1,\n            chunk: 2,\n            clamp: 3,\n            clone: 1,\n            cloneDeep: 1,\n            cloneDeepWith: 2,\n            cloneWith: 2,\n            compact: 1,\n            cond: 1,\n            conforms: 1,\n            constant: 1,\n            countBy: 2,\n            create: 2,\n            curry: 2,\n            curryRight: 2,\n            debounce: 3,\n            deburr: 1,\n            divide: 2,\n            drop: 2,\n            dropRight: 2,\n            dropRightWhile: 3,\n            dropWhile: 3,\n            endsWith: 3,\n            eq: 2,\n            escape: 1,\n            escapeRegExp: 1,\n            every: 2,\n            fill: 4,\n            filter: 2,\n            find: 3,\n            findIndex: 3,\n            findKey: 2,\n            findLast: 3,\n            findLastIndex: 3,\n            findLastKey: 2,\n            flatMap: 2,\n            flatMapDeep: 2,\n            flatMapDepth: 3,\n            flatten: 1,\n            flattenDeep: 1,\n            flattenDepth: 2,\n            flip: 1,\n            floor: 2,\n            forEach: 2,\n            forEachRight: 2,\n            forIn: 2,\n            forInRight: 2,\n            forOwn: 2,\n            forOwnRight: 2,\n            fromPairs: 1,\n            functions: 1,\n            functionsIn: 1,\n            get: 3,\n            groupBy: 2,\n            gt: 2,\n            gte: 2,\n            has: 2,\n            hasIn: 2,\n            head: 1,\n            identity: 1,\n            inRange: 3,\n            includes: 3,\n            indexOf: 3,\n            initial: 1,\n            invert: 1,\n            invertBy: 2,\n            isArguments: 1,\n            isArray: 1,\n            isArrayBuffer: 1,\n            isArrayLike: 1,\n            isArrayLikeObject: 1,\n            isBoolean: 1,\n            isBuffer: 1,\n            isDate: 1,\n            isElement: 1,\n            isEmpty: 1,\n            isEqual: 2,\n            isEqualWith: 3,\n            isError: 1,\n            isFinite: 1,\n            isFunction: 1,\n            isInteger: 1,\n            isLength: 1,\n            isMatch: 2,\n            isMatchWith: 3,\n            isNaN: 1,\n            isNative: 1,\n            isNil: 1,\n            isNull: 1,\n            isNumber: 1,\n            isObject: 1,\n            isObjectLike: 1,\n            isPlainObject: 1,\n            isRegExp: 1,\n            isSafeInteger: 1,\n            isSet: 1,\n            isString: 1,\n            isSymbol: 1,\n            isTypedArray: 1,\n            isUndefined: 1,\n            isWeakMap: 1,\n            isWeakSet: 1,\n            join: 2,\n            kebabCase: 1,\n            keyBy: 2,\n            keys: 1,\n            keysIn: 1,\n            last: 1,\n            lastIndexOf: 3,\n            lowerCase: 1,\n            lowerFirst: 1,\n            lt: 2,\n            lte: 2,\n            map: 2,\n            mapKeys: 2,\n            mapValues: 2,\n            matches: 1,\n            matchesProperty: 2,\n            max: 1,\n            maxBy: 2,\n            mean: 1,\n            meanBy: 2,\n            memoize: 2,\n            min: 1,\n            minBy: 2,\n            mixin: 3,\n            multiply: 2,\n            negate: 1,\n            noConflict: 0,\n            noop: 0,\n            now: 0,\n            nth: 2,\n            nthArg: 1,\n            once: 1,\n            orderBy: 3,\n            pad: 3,\n            padEnd: 3,\n            padStart: 3,\n            parseInt: 2,\n            partition: 2,\n            property: 1,\n            propertyOf: 1,\n            pullAll: 2,\n            pullAllBy: 3,\n            pullAllWith: 3,\n            random: 3,\n            range: 3,\n            rangeRight: 3,\n            reduce: 3,\n            reduceRight: 3,\n            reject: 2,\n            remove: 2,\n            repeat: 2,\n            rest: 2,\n            result: 3,\n            reverse: 1,\n            round: 2,\n            runInContext: 1,\n            sample: 1,\n            sampleSize: 2,\n            set: 3,\n            setWith: 4,\n            shuffle: 1,\n            size: 1,\n            slice: 3,\n            snakeCase: 1,\n            some: 2,\n            sortedIndex: 2,\n            sortedIndexBy: 3,\n            sortedIndexOf: 2,\n            sortedLastIndex: 2,\n            sortedLastIndexBy: 3,\n            sortedLastIndexOf: 2,\n            sortedUniq: 1,\n            sortedUniqBy: 2,\n            split: 3,\n            spread: 2,\n            startCase: 1,\n            startsWith: 3,\n            stubArray: 0,\n            stubFalse: 0,\n            stubObject: 0,\n            stubString: 0,\n            stubTrue: 0,\n            subtract: 2,\n            sum: 1,\n            sumBy: 2,\n            tail: 1,\n            take: 2,\n            takeRight: 2,\n            takeRightWhile: 2,\n            takeWhile: 2,\n            tap: 2,\n            template: 2,\n            throttle: 3,\n            thru: 2,\n            times: 2,\n            toArray: 1,\n            toInteger: 1,\n            toLength: 1,\n            toLower: 1,\n            toNumber: 1,\n            toPairs: 1,\n            toPairsIn: 1,\n            toPath: 1,\n            toPlainObject: 1,\n            toSafeInteger: 1,\n            toString: 1,\n            toUpper: 1,\n            transform: 3,\n            trim: 2,\n            trimEnd: 2,\n            trimStart: 2,\n            truncate: 3,\n            unary: 1,\n            unescape: 1,\n            uniq: 1,\n            uniqBy: 2,\n            uniqWith: 2,\n            uniqueId: 1,\n            unset: 2,\n            unzip: 1,\n            unzipWith: 2,\n            update: 3,\n            updateWith: 4,\n            upperCase: 1,\n            upperFirst: 1,\n            values: 1,\n            valuesIn: 1,\n            words: 2,\n            wrap: 2,\n            zipObject: 2,\n            zipObjectDeep: 2\n        }\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/util/ruleUtil.js":"'use strict';\n\nvar assignWith = require('lodash/assignWith');\nvar mapValues = require('lodash/mapValues');\nvar over = require('lodash/over');\n\nfunction combineVisitorObjects() {\n    for (var _len = arguments.length, objects = Array(_len), _key = 0; _key < _len; _key++) {\n        objects[_key] = arguments[_key];\n    }\n\n    var accumForAllVisitors = assignWith.apply(undefined, [{}].concat(objects, [function (objValue, sourceValue) {\n        return (objValue || []).concat(sourceValue);\n    }]));\n    return mapValues(accumForAllVisitors, over);\n}\n\nmodule.exports = {\n    combineVisitorObjects: combineVisitorObjects\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/util/methodDataByVersion/3.js":"'use strict';\n\nmodule.exports = {\n  add: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  after: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  ary: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  assign: {\n    aliases: [\"extend\"],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  at: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  before: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  bind: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  bindAll: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  bindKey: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  callback: {\n    aliases: [\"iteratee\"],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  camelCase: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  capitalize: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  ceil: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  chain: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  chunk: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  clone: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 4\n  },\n  cloneDeep: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 3\n  },\n  commit: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  compact: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  concat: {\n    aliases: [],\n    wrapper: true,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  constant: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  countBy: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  create: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  curry: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  curryRight: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  debounce: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 3\n  },\n  deburr: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  defaults: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  defaultsDeep: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  defer: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  delay: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  difference: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  drop: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  dropRight: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  dropRightWhile: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  dropWhile: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  endsWith: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 3\n  },\n  escape: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  escapeRegExp: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  every: {\n    aliases: [\"all\"],\n    wrapper: false,\n    shorthand: true,\n    chainable: false,\n    iteratee: true,\n    args: 3\n  },\n  fill: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 4\n  },\n  filter: {\n    aliases: [\"select\"],\n    wrapper: false,\n    shorthand: true,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  find: {\n    aliases: [\"detect\"],\n    wrapper: false,\n    shorthand: true,\n    chainable: false,\n    iteratee: true,\n    args: 3\n  },\n  findIndex: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: false,\n    iteratee: true,\n    args: 3\n  },\n  findKey: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: false,\n    iteratee: true,\n    args: 3\n  },\n  findLast: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: true,\n    args: 3\n  },\n  findLastIndex: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: false,\n    iteratee: true,\n    args: 3\n  },\n  findLastKey: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: false,\n    iteratee: true,\n    args: 3\n  },\n  findWhere: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  first: {\n    aliases: [\"head\"],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  flatten: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  flattenDeep: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  floor: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  flow: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  flowRight: {\n    aliases: [\"backflow\", \"compose\"],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  forEach: {\n    aliases: [\"each\"],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  forEachRight: {\n    aliases: [\"eachRight\"],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  forIn: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  forInRight: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  forOwn: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  forOwnRight: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  fromIndex: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 3\n  },\n  functions: {\n    aliases: [\"methods\"],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  get: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 3\n  },\n  groupBy: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  gt: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  gte: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  has: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  identity: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  inRange: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 3\n  },\n  includes: {\n    aliases: [\"contains\", \"include\"],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 3\n  },\n  indexBy: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  initial: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  intersection: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  invert: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  invoke: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  isArguments: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isArray: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isBoolean: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isDate: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isElement: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isEmpty: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isEqual: {\n    aliases: [\"eq\"],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 4\n  },\n  isError: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isFinite: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isFunction: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isMatch: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 4\n  },\n  isNaN: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isNative: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isNull: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isNumber: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isObject: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isPlainObject: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isRegExp: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isTypedArray: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  isUndefined: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  join: {\n    aliases: [],\n    wrapper: true,\n    shorthand: false,\n    chainable: false,\n    iteratee: false\n  },\n  kebabCase: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  keys: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  keysIn: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  last: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  lastIndexOf: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 3\n  },\n  lt: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  lte: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  map: {\n    aliases: [\"collect\"],\n    wrapper: false,\n    shorthand: true,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  mapKeys: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  mapValues: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  matches: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  matchesProperty: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  max: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: false,\n    iteratee: true,\n    args: 3\n  },\n  memoize: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  merge: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  method: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  methodOf: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  min: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: false,\n    iteratee: true,\n    args: 3\n  },\n  mixin: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 3\n  },\n  modArgs: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  negate: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  noConflict: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 0\n  },\n  noop: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 0\n  },\n  omit: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  once: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  pad: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 3\n  },\n  padLeft: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 3\n  },\n  padRight: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 3\n  },\n  pairs: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  parseInt: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  partial: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  partialRight: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  partition: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  pick: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  plant: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  pluck: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  pop: {\n    aliases: [],\n    wrapper: true,\n    shorthand: false,\n    chainable: false,\n    iteratee: false\n  },\n  property: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  propertyOf: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  pull: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  pullAt: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  push: {\n    aliases: [],\n    wrapper: true,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  random: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 3\n  },\n  range: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 3\n  },\n  rearg: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  reduce: {\n    aliases: [\"foldl\", \"inject\"],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: true,\n    args: 4\n  },\n  reduceRight: {\n    aliases: [\"foldr\"],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: true,\n    args: 4\n  },\n  reject: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  remove: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  repeat: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  replace: {\n    aliases: [],\n    wrapper: true,\n    shorthand: false,\n    chainable: false,\n    iteratee: false\n  },\n  rest: {\n    aliases: [\"tail\"],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  restParam: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  result: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: false,\n    iteratee: false,\n    args: 3\n  },\n  reverse: {\n    aliases: [],\n    wrapper: true,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  round: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  runInContext: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  sample: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  set: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 3\n  },\n  shift: {\n    aliases: [],\n    wrapper: true,\n    shorthand: false,\n    chainable: false,\n    iteratee: false\n  },\n  shuffle: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  size: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  slice: {\n    aliases: [],\n    wrapper: true,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 3\n  },\n  snakeCase: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  some: {\n    aliases: [\"any\"],\n    wrapper: false,\n    shorthand: true,\n    chainable: false,\n    iteratee: true,\n    args: 3\n  },\n  sort: {\n    aliases: [],\n    wrapper: true,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  sortBy: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  sortByAll: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  sortByOrder: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: true,\n    iteratee: false\n  },\n  sortedIndex: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: false,\n    iteratee: true,\n    iterateeIndex: 2,\n    args: 4\n  },\n  sortedLastIndex: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: false,\n    iteratee: true,\n    iterateeIndex: 2,\n    args: 4\n  },\n  splice: {\n    aliases: [],\n    wrapper: true,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  split: {\n    aliases: [],\n    wrapper: true,\n    shorthand: false,\n    chainable: false,\n    iteratee: false\n  },\n  spread: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  startCase: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  startsWith: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 3\n  },\n  sum: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: false,\n    iteratee: true,\n    args: 3\n  },\n  take: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  takeRight: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  takeRightWhile: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  takeWhile: {\n    aliases: [],\n    wrapper: false,\n    shorthand: true,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  tap: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  template: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  throttle: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 3\n  },\n  thru: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  times: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  toArray: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  toPlainObject: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  transform: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: true,\n    args: 4\n  },\n  trim: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  trimLeft: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  trimRight: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  trunc: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 3\n  },\n  unescape: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  union: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  uniq: {\n    aliases: [\"unique\"],\n    wrapper: false,\n    shorthand: true,\n    chainable: true,\n    iteratee: true,\n    args: 4\n  },\n  uniqueId: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 1\n  },\n  unshift: {\n    aliases: [],\n    wrapper: true,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  unzip: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  unzipWith: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: true,\n    args: 3\n  },\n  values: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  valuesIn: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 1\n  },\n  where: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  without: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  words: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: false,\n    iteratee: false,\n    args: 2\n  },\n  wrap: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  xor: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  zip: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false\n  },\n  zipObject: {\n    aliases: [\"object\"],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: false,\n    args: 2\n  },\n  zipWith: {\n    aliases: [],\n    wrapper: false,\n    shorthand: false,\n    chainable: true,\n    iteratee: true\n  }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/util/methodDataByVersion/4.js":"'use strict';\n\nmodule.exports = {\n    add: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    after: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    ary: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    assign: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    assignIn: {\n        aliases: [\"extend\"],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    assignInWith: {\n        aliases: [\"extendWith\"],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    assignWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    at: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    attempt: {\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false\n    },\n    before: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    bind: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    bindAll: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    bindKey: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    camelCase: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    capitalize: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    castArray: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    ceil: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    chain: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    chunk: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    clamp: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    clone: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    cloneDeep: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    cloneDeepWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    cloneWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    commit: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    compact: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    concat: {\n        aliases: [],\n        wrapper: true,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    cond: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    conforms: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    conformsTo: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    constant: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    countBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    create: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    curry: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    curryRight: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    debounce: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 3\n    },\n    deburr: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    defaultTo: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    defaults: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    defaultsDeep: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    defer: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    delay: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    difference: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    differenceBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: false\n    },\n    differenceWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    divide: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    drop: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    dropRight: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    dropRightWhile: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 3\n    },\n    dropWhile: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 3\n    },\n    endsWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    eq: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    escape: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    escapeRegExp: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    every: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    fill: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 4\n    },\n    filter: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    find: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: false,\n        iteratee: true,\n        args: 3\n    },\n    findIndex: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: false,\n        iteratee: true,\n        args: 3\n    },\n    findKey: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    findLast: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: true,\n        args: 3\n    },\n    findLastIndex: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: false,\n        iteratee: true,\n        args: 3\n    },\n    findLastKey: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    flatMap: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    flatMapDeep: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    flatMapDepth: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 3\n    },\n    flatten: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    flattenDeep: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    flattenDepth: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    flip: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    floor: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    flow: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    flowRight: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    forEach: {\n        aliases: [\"each\"],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    forEachRight: {\n        aliases: [\"eachRight\"],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    forIn: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    forInRight: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    forOwn: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    forOwnRight: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    fromPairs: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    functions: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    functionsIn: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    get: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    groupBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    gt: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    gte: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    has: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    hasIn: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    head: {\n        aliases: [\"first\"],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    identity: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    inRange: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    includes: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    indexBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: true\n    },\n    indexOf: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    initial: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    intersection: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    intersectionBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: false\n    },\n    intersectionWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    invert: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    invertBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    invoke: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false\n    },\n    invokeMap: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    isArguments: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isArray: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isArrayBuffer: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isArrayLike: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isArrayLikeObject: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isBoolean: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isBuffer: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isDate: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isElement: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isEmpty: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isEqual: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    isEqualWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    isError: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isFinite: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isFunction: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isInteger: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isLength: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isMap: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isMatch: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    isMatchWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    isNaN: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isNative: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isNil: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isNull: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isNumber: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isObject: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isObjectLike: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isPlainObject: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isRegExp: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isSafeInteger: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isSet: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isString: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isSymbol: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isTypedArray: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isUndefined: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isWeakMap: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    isWeakSet: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    iteratee: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    join: {\n        aliases: [],\n        wrapper: true,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    kebabCase: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    keyBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    keys: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    keysIn: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    last: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    lastIndexOf: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    lowerCase: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    lowerFirst: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    lt: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    lte: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    map: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    mapKeys: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    mapValues: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    matches: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    matchesProperty: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    max: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    maxBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    mean: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    meanBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    memoize: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    merge: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    mergeWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    method: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    methodOf: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    min: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    minBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    mixin: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 3\n    },\n    multiply: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    negate: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    next: {\n        aliases: [],\n        wrapper: true,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 0\n    },\n    noConflict: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 0\n    },\n    noop: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 0\n    },\n    now: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 0\n    },\n    nth: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    nthArg: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    omit: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    omitBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true\n    },\n    once: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    orderBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 3\n    },\n    over: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    overArgs: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    overEvery: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: false\n    },\n    overSome: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: false\n    },\n    pad: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    padEnd: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    padStart: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    parseInt: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    partial: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    partialRight: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    partition: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    pick: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    pickBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true\n    },\n    plant: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    pop: {\n        aliases: [],\n        wrapper: true,\n        shorthand: false,\n        chainable: false,\n        iteratee: false\n    },\n    property: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    propertyOf: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    pull: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    pullAll: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    pullAllBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: false,\n        iterateeIndex: 2,\n        args: 3\n    },\n    pullAllWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 3\n    },\n    pullAt: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    push: {\n        aliases: [],\n        wrapper: true,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    random: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    range: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 3\n    },\n    rangeRight: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 3\n    },\n    rearg: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    reduce: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: true,\n        args: 3\n    },\n    reduceRight: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: true,\n        args: 3\n    },\n    reject: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    remove: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    repeat: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    replace: {\n        aliases: [],\n        wrapper: true,\n        shorthand: false,\n        chainable: false,\n        iteratee: false\n    },\n    rest: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    result: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    reverse: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    round: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    runInContext: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    sample: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    sampleSize: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    set: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 3\n    },\n    setWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 4\n    },\n    shift: {\n        aliases: [],\n        wrapper: true,\n        shorthand: false,\n        chainable: false,\n        iteratee: false\n    },\n    shuffle: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    size: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    slice: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 3\n    },\n    snakeCase: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    some: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    sort: {\n        aliases: [],\n        wrapper: true,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    sortBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    sortedIndex: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        iterateeIndex: 2,\n        args: 2\n    },\n    sortedIndexBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: false,\n        iteratee: false,\n        iterateeIndex: 2,\n        args: 3\n    },\n    sortedIndexOf: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    sortedLastIndex: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        iterateeIndex: 2,\n        args: 2\n    },\n    sortedLastIndexBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: false,\n        iteratee: false,\n        iterateeIndex: 2,\n        args: 3\n    },\n    sortedLastIndexOf: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    sortedUniq: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    sortedUniqBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    splice: {\n        aliases: [],\n        wrapper: true,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    split: {\n        aliases: [],\n        wrapper: true,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    spread: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    startCase: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    startsWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    stubArray: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 0\n    },\n    stubFalse: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 0\n    },\n    stubObject: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 0\n    },\n    stubString: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 0\n    },\n    stubTrue: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 0\n    },\n    subtract: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    sum: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    sumBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    tail: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    take: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    takeRight: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    takeRightWhile: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    takeWhile: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    tap: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    template: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    throttle: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 3\n    },\n    thru: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    times: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: true,\n        args: 2\n    },\n    toArray: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    toFinite: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    toInteger: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    toLength: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    toLower: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    toNumber: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    toPairs: {\n        aliases: ['entries'],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    toPairsIn: {\n        aliases: ['entriesIn'],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    toPath: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    toPlainObject: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    toSafeInteger: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    toString: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    toUpper: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    transform: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: true,\n        args: 3\n    },\n    trim: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    trimEnd: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    trimStart: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    truncate: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 3\n    },\n    unary: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    unescape: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    union: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    unionBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: false\n    },\n    unionWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    uniq: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    uniqBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    uniqWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    uniqueId: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    unset: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    unshift: {\n        aliases: [],\n        wrapper: true,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    unzip: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    unzipWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: true,\n        args: 2\n    },\n    update: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 3\n    },\n    updateWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 4\n    },\n    upperCase: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    upperFirst: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 1\n    },\n    value: {\n        aliases: ['toJSON', 'valueOf'],\n        wrapper: true,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 0\n    },\n    values: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    valuesIn: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 1\n    },\n    without: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    words: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: false,\n        iteratee: false,\n        args: 2\n    },\n    wrap: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    xor: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    xorBy: {\n        aliases: [],\n        wrapper: false,\n        shorthand: true,\n        chainable: true,\n        iteratee: true\n    },\n    xorWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    zip: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    },\n    zipObject: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    zipObjectDeep: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false,\n        args: 2\n    },\n    zipWith: {\n        aliases: [],\n        wrapper: false,\n        shorthand: false,\n        chainable: true,\n        iteratee: false\n    }\n};","/home/travis/build/npmtest/node-npmtest-eslint-plugin-lodash/node_modules/eslint-plugin-lodash/lib/util/methodDataByVersion/convert.js":"'use strict';\n// aliases wrapper wrapperAliases shorthand chainable iteratee iterateeIndex args\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar _ = require('lodash');\nvar data = require('./4');\nvar fs = require('fs');\nvar path = require('path');\nvar methodNames = _([].concat(_toConsumableArray(_.values(data.aliases)), _toConsumableArray(data.wrapper), _toConsumableArray(data.shorthand), _toConsumableArray(data.chainable), _toConsumableArray(data.iteratee.any), _toConsumableArray(_.keys(data.iteratee.differentIndex)), _toConsumableArray(_.keys(data.args)))).uniq().sortBy().value();\nvar methodRecords = _.map(methodNames, function (method) {\n    var res = {\n        aliases: _(data.aliases).pickBy(function (val) {\n            return val === method;\n        }).keys().value(),\n        wrapper: _.includes(data.wrapper, method),\n        shorthand: _.includes(data.shorthand, method),\n        chainable: _.includes(data.chainable, method),\n        iteratee: _.includes(data.iteratee.any, method)\n    };\n    if (_.has(data.iteratee.differentIndex, method)) {\n        _.set(res, 'iterateeIndex', data.iteratee.differentIndex[method]);\n    }\n    if (_.has(data.args, method)) {\n        _.set(res, 'args', data.args[method]);\n    }\n    return res;\n});\nvar result = _.zipObject(methodNames, methodRecords);\nfs.writeFileSync(path.resolve(__dirname, '4.js'), '\\'use strict\\'\\nmodule.exports = ' + JSON.stringify(result, null, 2));"}